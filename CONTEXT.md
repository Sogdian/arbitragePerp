# Контекст проекта ArbitragePerp

## Поддерживаемые биржи

Проект поддерживает следующие криптовалютные биржи для арбитража на фьючерсах:

1. **Bybit** (bybit) готово
2. **Gate.io** (gate) готово
3. **MEXC** (mexc) жду
4. **Binance** (binance) готово
5. **Bitget** (bitget)
6. **BingX** (bingx)
7. **OKX** (okx)
8. **XT.com** (xt)

**Примечание:** LBank (lbank) имеет реализацию в коде, но временно отключен для арбитража.

## Описание проекта
Бот для анализа арбитража криптовалюты на фьючерсах между биржами. Поддерживает следующие биржи: Bybit, Gate.io, MEXC, XT.com, Binance, Bitget, OKX, BingX.

## Спреды открытия и закрытия
opening_spread = (bid_short - ask_long) / ask_long * 100
closing_spread = (bid_long - ask_short) / ask_short * 100

## История создания
Проект создан на основе логики из проекта `arbitrage`, но адаптирован для работы с фьючерсами и фандингами.

## Архитектура

### Основные компоненты:
1. **exchanges/** - Модуль для работы с биржами
   - `async_base_exchange.py` - Базовый класс для всех бирж
   - `async_bybit.py` - Клиент Bybit для фьючерсов
   - `async_gate.py` - Клиент Gate.io для фьючерсов
   - `async_mexc.py` - Клиент MEXC для фьючерсов
   - `async_lbank.py` - Клиент LBank для фьючерсов
   - `async_xt.py` - Клиент XT.com для фьючерсов
   - `async_binance.py` - Клиент Binance для фьючерсов
   - `async_bitget.py` - Клиент Bitget для фьючерсов
   - `async_okx.py` - Клиент OKX для фьючерсов
   - `async_bingx.py` - Клиент BingX для фьючерсов
   - `coin_list_fetchers.py` - Модуль для получения списка всех доступных монет на фьючерсах для каждой биржи

2. **bot.py** - Основной бот, который:
   - Парсит вводные данные в формате: "монета Long (биржа), Short (биржа)"
   - Получает данные о ценах фьючерсов и фандингах с обеих бирж
   - Вычисляет спреды
   - Выводит информацию в лог

3. **input_parser.py** - Парсер вводных данных
   - Парсит формат: "монета Long (биржа), Short (биржа) размер"
   - Извлекает размер инвестиций в USDT (обязательный параметр)

4. **scan_spreads.py** - Скрипт для непрерывного мониторинга спредов между всеми поддерживаемыми биржами
   - Автоматически обнаруживает все доступные монеты на каждой бирже
   - Сканирует арбитражные возможности по парам бирж
   - Использует intersection монет (только общие монеты для каждой пары бирж)
   - Периодически обновляет список монет перед каждым циклом сканирования

5. **one_coin_bot.py** - Скрипт для анализа одной монеты на всех доступных биржах
   - Принимает монету как аргумент командной строки (например, `python one_coin_bot.py CLO`)
   - Автоматически определяет, на каких биржах доступна монета (исключая LBank)
   - Получает цены и фандинги со всех доступных бирж параллельно
   - Анализирует все возможные пары бирж (Long на одной, Short на другой)
   - Для каждой пары проверяет ликвидность и новости (делистинг и безопасность)
   - Выводит результаты по мере обработки в формате: цены, фандинги, спреды и вердикт (✅ арбитражить / ❌ не арбитражить)
   - Использует отдельный лог-файл (SCAN_LOG_FILE из .env, по умолчанию `scan_one_coin.log`)
   - Переиспользует логику проверки ликвидности и новостей из `scan_spreads.py`

6. **news_monitor.py** - Модуль для мониторинга новостей о делистинге монет
   - Поддерживает Bybit, Gate.io, MEXC, XT.com, Binance, Bitget, OKX, BingX
   - HTML-скрапинг и API-запросы для получения объявлений
   - Фильтрация по ключевым словам делистинга

7. **announcements_monitor.py** - Модуль для мониторинга новостей о безопасности/взломах
   - Проверяет объявления на наличие упоминаний монеты и ключевых слов безопасности
   - Поддерживает догруз полного контента статей для более точного поиска
   - Интегрирован в `bot.py` для автоматической проверки после делистинга

8. **config.py** - Конфигурация (логирование, Telegram настройки)

9. **telegram_sender.py** - Модуль для отправки сообщений в Telegram каналы
   - Поддержка режимов test/prod (переключение между тестовым и продакшн каналами)
   - Антидублирование спредов (логика повторных отправок)
   - Автоматический выбор канала на основе ENV_MODE
   - Поддержка отправки изображений через метод `send_photo()` (требует Pillow)

## Формат ввода
```
монета Long (биржа), Short (биржа) [размер]
```
Пример: `CVC Long (bybit), Short (gate) 100`
Пример без размера: `CVC Long (bybit), Short (gate)` (будет использован `SCAN_COIN_INVEST`)

**Важно:** 
- Размер инвестиций в USDT опционален. Если не указан, используется `SCAN_COIN_INVEST` из `.env` (по умолчанию 50 USDT)
- Бот использует этот размер для проверки ликвидности на обеих биржах (Long и Short)

**Неинтерактивный режим:**
- `--no-monitor` - отключить мониторинг спредов (только анализ)
- `--no-prompt` - пропустить интерактивный промпт о ручном открытии позиций
- `--monitor` - принудительно включить мониторинг спредов

## Формат вывода
Бот выводит:
- Цена монеты на фьючерс (монета) биржа: __
- Фандинг (монета) биржа: __
- Спред на цену на фьючерс (биржа1 и биржа2): __
- Спред на фандинги (биржа1 и биржа2): __

## API эндпоинты

**Важно:** Все используемые эндпоинты - публичные (market data), API ключи не требуются!

### Bybit:
- **Базовый URL:** `https://api.bybit.com`
- **Тикер фьючерса:** `/v5/market/tickers` - публичный API
- **Фандинг (текущая ставка):** `/v5/market/tickers` - публичный API (приоритет)
  - Возвращает текущую/следующую ставку фандинга в поле `fundingRate` (соответствует UI "Текущая ставка")
  - Также возвращает `nextFundingTime` (timestamp следующей выплаты funding)
- **Фандинг (fallback на историю):** `/v5/market/funding/history` - публичный API
  - Используется как fallback, если tickers не вернул fundingRate
  - Возвращает предыдущую примененную ставку (UI "Предыдущая ставка")
- **Обязательные параметры:**
  - Тикер: `category=linear`, `symbol=COINUSDT`
  - Фандинг (tickers): `category=linear`, `symbol=COINUSDT`
  - Фандинг (history): `category=linear`, `symbol=COINUSDT`, `limit=1`
- **Формат символов:** `COINUSDT` (без подчеркивания, например, `CVCUSDT`, `BTCUSDT`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Возвращает данные в формате `{"retCode": 0, "result": {...}}`
  - Если `retCode != 0`, монета недоступна или произошла ошибка
  - Тикер возвращает `lastPrice`, `bid1Price`, `ask1Price`
  - **Фандинг (текущая ставка):** Приоритетно используется `fundingRate` из `/v5/market/tickers` (текущая/следующая ставка, как в UI). Если не получен, используется fallback на `/v5/market/funding/history` (предыдущая примененная ставка)
- **Валидация цен (sanity-check):**
  - Bybit иногда возвращает `"0"` или пустые значения для `bid1Price`/`ask1Price` на неликвидных инструментах
  - Реализована функция `_safe_px()` для безопасного преобразования цен с проверками:
    - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
    - Проверка, что цена > 0
    - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
    - Порог 10x обычно достаточен; для очень волатильных инструментов можно сделать параметром (5x-20x)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask

### OKX:
- **Базовый URL:** `https://www.okx.com`
- **Тикер фьючерса:** `/api/v5/market/ticker` - публичный API
- **Фандинг:** `/api/v5/public/funding-rate` - публичный API
- **Orderbook:** `/api/v5/market/books` - публичный API
- **Обязательные параметры:**
  - Тикер: `instId=COIN-USDT-SWAP` (USDT-M perpetual)
  - Фандинг: `instId=COIN-USDT-SWAP`
  - Orderbook: `instId=COIN-USDT-SWAP`, `sz` (от 1 до 400)
- **Формат символов:** `COIN-USDT-SWAP` (с дефисами и суффиксом SWAP, например, `CVC-USDT-SWAP`, `BTC-USDT-SWAP`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Возвращает данные в формате `{"code": "0", "msg": "", "data": [...]}`
  - Успешные ответы имеют `code: "0"` (строка)
  - Все данные возвращаются в поле `data` как список (даже для одного инструмента)
  - Тикер возвращает `last`, `bidPx`, `askPx` в первом элементе списка `data[0]`
  - Фандинг возвращает `fundingRate` в первом элементе списка `data[0]` (в десятичном формате, например, 0.0001 = 0.01%)
  - Orderbook возвращает `bids` и `asks` как списки `[[price, size, ...], ...]` в первом элементе списка `data[0]`
  - Из orderbook извлекаются только первые два элемента каждого уровня (price и size)
  - Если данные не получены или символ не найден, монета недоступна или произошла ошибка
- **Проверка ошибок API:**
  - Реализован метод класса `_is_api_error()` для проверки поля `code` в ответе
  - Если `code` присутствует и не равен `"0"` (строка), ответ считается ошибкой
  - Улучшенное логирование: в warning указывается `symbol` и детали ошибки для диагностики
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `last` более чем в 10 раз (в любую сторону), используется `last` как fallback
  - Проверка `last`: если `last <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `last`
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask

### BingX:
- **Базовый URL:** `https://open-api.bingx.com`
- **Тикер фьючерса:** `/openApi/swap/v2/quote/ticker` - публичный API
- **Фандинг:** `/openApi/swap/v2/quote/premiumIndex` - публичный API (текущая ставка фандинга)
- **Orderbook:** `/openApi/swap/v2/quote/depth` - публичный API
- **Обязательные параметры:**
  - Тикер: `symbol=COIN-USDT` (USDT-M perpetual)
  - Фандинг: `symbol=COIN-USDT`
  - Orderbook: `symbol=COIN-USDT`, `limit` (от 5 до 200)
- **Формат символов:** `COIN-USDT` (с дефисом, например, `CVC-USDT`, `BTC-USDT`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Возвращает данные в формате `{"code": 0, "msg": "", "data": {...}}`
  - Успешные ответы имеют `code: 0` (число)
  - Тикер возвращает `lastPrice`, `bidPrice`, `askPrice` в поле `data`
  - Фандинг возвращает текущую ставку в поле `data` с fallback на несколько ключей: `lastFundingRate`, `fundingRate`, `fundingRateNext` (в десятичном формате, например, 0.0001 = 0.01%)
  - Orderbook возвращает `bids` и `asks` как списки `[[price, size], ...]` в поле `data`
  - Если данные не получены или символ не найден, монета недоступна или произошла ошибка
- **Проверка ошибок API:**
  - Реализован метод класса `_is_api_error()` для проверки поля `code` в ответе
  - Если `code` присутствует и не равен `0`, ответ считается ошибкой
  - Улучшенное логирование: в warning указывается `symbol`, `code` и `msg` для диагностики
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Валидация orderbook:**
  - Реализована функция `_clean()` для очистки уровней orderbook
  - Пропускает битые уровни вместо падения всего метода
  - Проверка формата уровней: убеждается, что каждый уровень - это список/кортеж длины >= 2
  - Проверка конвертации в float: убеждается, что элементы можно конвертировать в `float`
  - Проверка, что `px > 0` и `sz > 0`
  - Сортировка: bids по убыванию price, asks по возрастанию price
  - Обрезание до `limit_i`, если API вернул больше уровней

### Gate.io:
- **Базовый URL:** `https://api.gateio.ws`
- **Тикер фьючерса:** `/api/v4/futures/usdt/tickers` - публичный API
- **Фандинг (текущая ставка):** `/api/v4/futures/usdt/contracts/{contract}` - публичный API
  - Возвращает текущую ставку фандинга в поле `funding_rate` (соответствует UI "Текущая ставка")
  - Fallback: `funding_rate_indicative` (индикативная ставка)
  - **Fallback на историю:** `/api/v4/futures/usdt/funding_rate` - возвращает предыдущую примененную ставку (UI "Предыдущая ставка")
- **Orderbook:** `/api/v4/futures/usdt/order_book` - публичный API
- **Обязательные параметры:**
  - Тикер: `contract=COIN_USDT`
  - Фандинг: `contract=COIN_USDT`, `limit=1`
  - Orderbook: `contract=COIN_USDT`, `limit` (от 1 до 200)
- **Формат символов:** `COIN_USDT` (с подчеркиванием, например, `CVC_USDT`, `BTC_USDT`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Может возвращать данные как список или словарь
  - Тикер возвращает `last`, `bid`, `ask` (или `highest_bid`/`lowest_ask`)
  - **Фандинг (текущая ставка):** Используется эндпоинт `/api/v4/futures/usdt/contracts/{contract}`, который возвращает текущую ставку в поле `funding_rate` (соответствует UI "Текущая ставка"). Fallback: `funding_rate_indicative` (индикативная ставка). Если не удалось получить, используется fallback на `/api/v4/futures/usdt/funding_rate` (история, предыдущая примененная ставка, UI "Предыдущая ставка")
  - Если данные не получены, монета недоступна или произошла ошибка
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 20 раз (в любую сторону), используется `lastPrice` как fallback (порог 20x для микро-альтов)
  - Для микро-альтов с ценой < 0.0001 sanity-check отключается (могут быть реальные скачки)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Поддержка альтернативных названий полей: `bid`/`highest_bid`, `ask`/`lowest_ask`
  - Проверка правильного контракта в списке: если API возвращает список, ищется точный контракт по полю `contract`
  - Используется в `get_futures_ticker()` для bid/ask
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Парсинг orderbook (поддержка разных форматов):**
  - Реализован метод `_parse_ob_levels()` для нормализации форматов orderbook
  - Gate.io может возвращать уровни в разных форматах:
    1. **REST/WS-legacy формат:** `[{"p":"97.1","s":2245}, ...]` (словари с ключами `p`/`price` и `s`/`size`)
    2. **REST формат:** `[["97.1","2245"], ...]` или `[[price, size], ...]` (списки/кортежи)
  - Метод нормализует оба формата к единому виду: `[[price(float), size(float)], ...]`
  - Обработка ошибок: проверка типов, конвертация в float, валидация значений
  - Нормализация размера: если `size < 0`, применяется `abs(size)` (на всякий случай)
  - Защита от безумных ответов: ограничение на 5000 уровней
  - Это предотвращает ошибки "неверный формат bids" и корректно обрабатывает оба формата ответов Gate.io

### MEXC:
- **Базовый URL:** `https://contract.mexc.com` (отдельный домен для фьючерсов)
- **Fallback URL:** `https://futures.mexc.com` (часто более стабильный домен для futures)
- **Тикер фьючерса:** `/api/v1/contract/ticker` - публичный API
- **Фандинг:** `/api/v1/contract/funding_rate/{symbol}` - публичный API (символ в path)
- **Orderbook:** `/api/v1/contract/depth/{symbol}` - публичный API (символ в path)
- **Обязательные параметры:**
  - Тикер: `symbol=COIN_USDT` (query параметр, с fallback на `COINUSDT` без подчеркивания)
  - Фандинг: `{symbol}` в path (например, `/api/v1/contract/funding_rate/DN_USDT`), с fallback на `COINUSDT` без подчеркивания
  - Orderbook: `{symbol}` в path (например, `/api/v1/contract/depth/DN_USDT`), `limit` в query (от 1 до 200), с fallback на `COINUSDT` без подчеркивания
- **ВАЖНО:** По Contract V1 API, `funding_rate` и `depth` используют символ в path-параметре, а не в query параметрах. Это критично для корректной работы API.
- **Формат символов:** `COIN_USDT` (с подчеркиванием, например, `CVC_USDT`, `BTC_USDT`)
  - Если запрос с `_USDT` не дал данных, вернул ошибку (`code != 0`), или вернул dict без полезных полей (`data`, `result`, `code`), автоматически пробуется формат без подчеркивания (`COINUSDT`)
  - Fallback применяется во всех методах (ticker, funding, orderbook) для совместимости с разными версиями API
  - **Алиасы/коллизии имен (важно для UI):** иногда "отображаемое" имя пары в UI не совпадает с `symbol` в API.
    - Пример: UI `FUNUSDT` соответствует API `SPORTFUN_USDT`, а API `FUN_USDT` — это другой контракт (`FUNTOKEN_USDT`).
    - В коде добавлены алиасы в `exchanges/async_mexc.py`, а список монет для MEXC теперь извлекается по `displayName`, если он доступен.
  - Проверка `code` выполняется только если поле присутствует в ответе (защита от нестандартных форматов)
  - **`looks_empty` проверка:** Сужена до проверки только верхнего уровня (`data`, `result`, `code`), так как для MEXC поля `bids`/`asks`/`lastPrice`/`last` обычно находятся внутри `data`, а не на верхнем уровне. Это предотвращает ложные fallback при валидных ответах вида `{"code":0,"data":...}`
  - В `get_funding_rate()` `symbol_to_find` строится от фактически используемого `symbol` (после fallback, если он был применен)
  - **Поддержка полей `data` и `result`:** Во всех методах (ticker, funding, orderbook) сначала пробуется `data.get("data")`, если `None` — используется `data.get("result")`, если и оно `None` — используется весь `data` (fallback для совместимости с разными форматами ответов API)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Может возвращать данные как список или словарь в поле `data`
  - Проверяется, что `code == 0` для успешного ответа
  - Тикер возвращает `lastPrice`, `bid1`, `ask1`
  - Фандинг возвращает `fundingRate` (уже в десятичном формате, например, 0.000052 = 0.0052%)
  - Если данные не получены или символ не совпадает, монета недоступна или произошла ошибка
- **Канонизация символов:**
  - Реализована функция `_canon()` для нормализации символов при сравнении
  - Убирает дефисы и подчеркивания: `GPSUSDT`, `GPS-USDT`, `GPS_USDT` → `GPSUSDT`
  - Используется в `get_funding_rate()` для надежного поиска символа в списке
  - Это позволяет находить символы независимо от формата, в котором их возвращает API
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
  - Порог 10x обычно достаточен; для очень волатильных инструментов можно сделать параметром (5x-20x)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Используется в `get_futures_ticker()` для bid/ask
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Безопасный поиск фандинга:**
  - Убран опасный fallback `item[0]` при поиске фандинга в списке
  - Если символ не найден в списке, возвращается `None` вместо использования фандинга другой монеты
  - Используется канонизация символов для надежного сравнения
  - `symbol_to_find` строится от фактически используемого `symbol` (после fallback, если он был применен)
  - Улучшенное логирование: в warning указывается `coin`, `tried` (фактический символ) и `want` (канонизированный символ для поиска)
  - Поддержка полей `data` и `result`: сначала пробуется `data.get("data")`, если `None` — используется `data.get("result")`
  - Проверка перед парсингом: если `data.get("data")` и `data.get("result")` оба `None`, логируется предупреждение о неожиданном формате
  - **Валидация symbol после fallback:** После получения `item` проверяется, что `item.get("symbol")` (с канонизацией) совпадает с запрошенным `symbol_to_find`. Это особенно важно после fallback, чтобы убедиться, что получен фандинг для правильной монеты
  - **Улучшенное логирование валидации:** В warning показываются и raw, и canon версии символов для лучшей диагностики: `получен фандинг для {item_symbol} (canon={got_symbol}) вместо {symbol} (want raw) / {symbol_to_find} (want canon)`
  - Это предотвращает получение фандинга от неправильной монеты и ускоряет диагностику проблем
- **Парсинг orderbook (поддержка разных форматов и доменов):**
  - Реализован метод `_parse_ob_levels()` для нормализации форматов orderbook
  - MEXC может возвращать уровни в разных форматах:
    1. **Списки:** `[["price","size"], ...]` или `[[price, size], ...]` (обычный формат)
    2. **Словари:** `[{"price":"...","quantity":"..."}, ...]` (реже, но встречается)
  - Метод нормализует оба формата к единому виду: `[[price(float), size(float)], ...]`
  - Обработка ошибок: проверка типов, конвертация в float, валидация значений
  - Нормализация размера: если `size < 0`, применяется `abs(size)` (на всякий случай)
  - **Fallback на альтернативный домен:** Реализован метод `_request_json_with_domain_fallback()` для автоматического переключения между доменами при ошибках соединения
  - При ошибке соединения на основном домене (`contract.mexc.com`) автоматически пробуется fallback домен (`futures.mexc.com`)
  - Короткий backoff (0.25 секунды) между попытками для снижения нагрузки
  - Ограничение `limit`: автоматически ограничивается в диапазоне 1-200 (`limit_i = max(1, min(int(limit), 200))`)
  - Это предотвращает ошибки соединения и корректно обрабатывает оба формата ответов MEXC

### LBank:
- **Базовый URL:** `https://lbkperp.lbank.com` (отдельный домен для фьючерсов)
- **Тикер фьючерса:** `/cfd/openApi/v1/pub/marketData` - публичный API
- **Фандинг:** `/cfd/openApi/v1/pub/marketData` - публичный API
- **Orderbook:** `/cfd/openApi/v1/pub/depth` - публичный API
- **Обязательный параметр:** `productGroup=SwapU` (должен передаваться во всех запросах)
- **Формат символов:** `COINUSDT` (без подчеркивания, например, `IOTAUSDT`, `BTCUSDT`)
- **Примечание:** 
  - LBank использует публичный API, **API ключи не требуются**
  - API может возвращать пустые массивы данных для некоторых монет
  - Если монета недоступна, API вернет `data: []`
  - Для надежности сначала запрашивается список всех доступных инструментов через `/cfd/openApi/v1/pub/instrument`
  - Если данные не получены, монета помечается как недоступная/делистированная
- **Fallback для orderbook:**
  - Эндпоинт `/cfd/openApi/v1/pub/depth` может быть капризнее, чем `marketData`, и требовать другой формат символа
  - При получении orderbook пробуются несколько вариантов символа:
    1. `symbol_main` - символ, полученный через `resolve_symbol()` (из кеша инструментов)
    2. `symbol_norm` - нормализованный символ через `_normalize_symbol()` (например, `BTCUSDT`)
    3. `symbol_norm.lower()` - нижний регистр (например, `btcusdt`)
  - Если один из вариантов успешно возвращает данные, используется он
  - Если все варианты не сработали, выводится warning с перечислением всех попыток
- **Обработка HTTP 404:**
  - HTTP 404 для LBank означает, что публичный endpoint недоступен или неверные параметры
  - Теперь 404 логируется как warning с деталями URL и параметров для диагностики
  - Это помогает понять, является ли проблема в неверном формате символа или временной недоступности API
- **Кеширование инструментов:**
  - Список инструментов кешируется в памяти на 5 минут (TTL 300 секунд)
  - Это снижает количество запросов к API и риск rate-limit
  - Кеш обновляется автоматически при истечении TTL
- **Канонизация символов:**
  - Реализована функция `_canon()` для нормализации символов при сравнении
  - Убирает дефисы и подчеркивания: `GPSUSDT`, `GPS-USDT`, `GPS_USDT` → `GPSUSDT`
  - Используется в `_pick_market_item()` и `resolve_symbol()` для надежного поиска
  - Это позволяет находить символы независимо от формата, в котором их возвращает API
- **Проверка ошибок API:**
  - Реализована функция `_check_api_error()` для проверки ошибок в ответах API
  - Проверяет `success == False` и `str(error_code) != "0"` (корректно обрабатывает строковые значения типа `"0000"`)
  - Используется во всех методах (ticker, funding, orderbook) перед парсингом данных
  - Это предотвращает парсинг мусора/пустоты при ошибках API и корректно обрабатывает случаи, когда API возвращает ошибку вместо данных
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
  - Порог 10x обычно достаточен; для очень волатильных инструментов можно сделать параметром (5x-20x)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Используется в `_parse_ticker_response()` для bid/ask и может быть переиспользован в других местах
  - Это предотвращает использование мусорных значений типа `"2240434730514.30"`, `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Валидация orderbook:**
  - Проверка формата уровней: убеждается, что `bids[0]` и `asks[0]` - это список/кортеж длины >= 2
  - Проверка конвертации в float: убеждается, что элементы `bids[0][0]`, `bids[0][1]`, `asks[0][0]`, `asks[0][1]` можно конвертировать в `float`
  - Защита от строк, объектов или невалидных типов данных
  - Это предотвращает падения в `check_liquidity` при неверном формате данных
- **Упрощенная логика поиска:**
  - Везде используется единая функция `_pick_market_item()` для поиска нужного символа
  - Убраны special-case для dict payload, что делает код проще и надежнее
  - Функция проверяет поля `data` и `result` в ответе API
  - Консистентное использование `(list, tuple)` для проверки типов в depth парсере и orderbook

### XT.com:
- **Базовый URL:** `https://fapi.xt.com` (отдельный домен для фьючерсов)
- **Тикер фьючерса:** `/future/market/v1/public/q/ticker` - публичный API
- **Фандинг:** `/future/market/v1/public/q/funding-rate` - публичный API
- **Обязательные параметры:**
  - Тикер: `symbol=coin_usdt`
  - Фандинг: `symbol=coin_usdt`
- **Формат символов:** `coin_usdt` (нижний регистр, с подчеркиванием, например, `cvc_usdt`, `gps_usdt`, `btc_usdt`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Возвращает данные в формате `{"returnCode": 0, "msgInfo": "success", "result": {...}}`
  - Если `returnCode != 0`, монета недоступна или произошла ошибка
  - Тикер возвращает `c` (last price), `b` (bid), `a` (ask) в поле `result`
  - Фандинг возвращает `fundingRate` в поле `result` (в десятичном формате, например, -0.02 = -2.0%)
  - **КРИТИЧНО:** Символы чувствительны к регистру - обязательно использовать нижний регистр
  - Если данные не получены, монета недоступна или произошла ошибка
- **Валидация цен (sanity-check):**
  - XT.com иногда возвращает аномально большие значения для `bid`/`ask` (например, `184010056.0` вместо `0.00797`)
  - Реализована проверка на разумность значений:
    - Если `bid` или `ask` присутствуют и > 0, проверяется отклонение от `lastPrice`
    - Если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
    - Если `bid` или `ask` отсутствуют или равны 0, используется `lastPrice`
  - Это предотвращает использование некорректных данных, которые могут привести к космическим значениям спредов

### Bitget:
- **Базовый URL:** `https://api.bitget.com`
- **Тикер фьючерса:** `/api/v2/mix/market/ticker` - публичный API
- **Фандинг:** `/api/v2/mix/market/current-fund-rate` - публичный API
- **Orderbook:** `/api/v2/mix/market/merge-depth` - публичный API
- **Обязательные параметры:**
  - Тикер: `symbol=COINUSDT`, `productType=usdt-futures` (USDT-M perpetual)
  - Фандинг: `symbol=COINUSDT`, `productType=usdt-futures`
  - Orderbook: `symbol=COINUSDT`, `productType=usdt-futures`, `limit` (строка "50" или "max")
- **Формат символов:** `COINUSDT` (без подчеркивания и суффиксов, например, `CVCUSDT`, `BTCUSDT`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Возвращает данные в формате `{"code": "00000", "msg": "success", "data": {...}}`
  - Успешные ответы имеют `code: "00000"` или `code: 0`
  - Тикер возвращает `lastPr`, `bidPr`, `askPr` в поле `data` (v2 API)
  - Фандинг возвращает `fundingRate` в поле `data` (в десятичном формате, например, 0.0001 = 0.01%)
  - Orderbook возвращает `bids` и `asks` как списки `[[price, size], ...]` в поле `data`
  - Если данные не получены или символ не найден, монета недоступна или произошла ошибка
- **Проверка ошибок API:**
  - Реализован метод класса `_is_api_error()` для проверки наличия поля `code` в ответе
  - Если `code` присутствует и не равен `"00000"` или `0`, ответ считается ошибкой
  - Улучшенное логирование: в warning указывается `symbol`, `code` и `msg` для диагностики
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
  - Порог 10x обычно достаточен; для очень волатильных инструментов можно сделать параметром (5x-20x)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Используется в `get_futures_ticker()` для bid/ask
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Валидация orderbook:**
  - Проверка формата уровней: убеждается, что `bids[0]` и `asks[0]` - это список/кортеж длины >= 2
  - Проверка конвертации в float: убеждается, что элементы `bids[0][0]`, `bids[0][1]`, `asks[0][0]`, `asks[0][1]` можно конвертировать в `float`
  - Защита от строк, объектов или невалидных типов данных
  - Ограничение `limit`: Bitget принимает `limit` от 1 до 200, код автоматически ограничивает значение в этих пределах (`limit_i = max(1, min(int(limit), 200))`)
  - Это предотвращает падения в `check_liquidity` при неверном формате данных
- **Улучшенное логирование:**
  - Во всех методах добавлено детальное логирование с указанием `symbol` для диагностики
  - Логируются пустые ответы, ошибки API, неожиданные форматы данных, отсутствие полей
  - Это ускоряет диагностику проблем при работе с API

### Binance:
- **Базовый URL:** `https://fapi.binance.com` (отдельный домен для USDT-M фьючерсов)
- **Тикер фьючерса:** `/fapi/v1/ticker/24hr` - публичный API
- **Фандинг:** `/fapi/v1/premiumIndex` - публичный API
- **Orderbook:** `/fapi/v1/depth` - публичный API
- **Обязательные параметры:**
  - Тикер: `symbol=COINUSDT`
  - Фандинг: `symbol=COINUSDT`
  - Orderbook: `symbol=COINUSDT`, `limit` (от 5 до 5000)
- **Формат символов:** `COINUSDT` (без подчеркивания, например, `CVCUSDT`, `BTCUSDT`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Возвращает данные напрямую (без обертки в `result`)
  - Тикер возвращает `lastPrice`, `bidPrice`, `askPrice`
  - Фандинг возвращает `lastFundingRate` (в десятичном формате, например, 0.0001 = 0.01%)
  - Orderbook возвращает `bids` и `asks` как списки `[[price, size], ...]` (обычно строки)
  - Binance возвращает ошибки в формате `{"code": -1121, "msg": "Invalid symbol."}`
  - Успешные ответы не содержат поле `code`, ошибки содержат отрицательные коды
  - Если данные не получены или символ не найден, монета недоступна или произошла ошибка
- **Проверка ошибок API:**
  - Реализован метод класса `_is_api_error()` для проверки наличия поля `code` в ответе
  - Если `code` присутствует, ответ считается ошибкой
  - Улучшенное логирование: в warning указывается `symbol`, `code` и `msg` для диагностики
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
  - Порог 10x обычно достаточен; для очень волатильных инструментов можно сделать параметром (5x-20x)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Используется в `get_futures_ticker()` для bid/ask
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Валидация orderbook:**
  - Проверка формата уровней: убеждается, что `bids[0]` и `asks[0]` - это список/кортеж длины >= 2
  - Проверка конвертации в float: убеждается, что элементы `bids[0][0]`, `bids[0][1]`, `asks[0][0]`, `asks[0][1]` можно конвертировать в `float`
  - Защита от строк, объектов или невалидных типов данных
  - Ограничение `limit`: Binance принимает `limit` от 5 до 5000, код автоматически ограничивает значение в этих пределах (`limit_i = max(5, min(int(limit), 5000))`)
  - Это предотвращает падения в `check_liquidity` при неверном формате данных
- **Улучшенное логирование:**
  - Во всех методах добавлено детальное логирование с указанием `symbol` для диагностики
  - Логируются пустые ответы, ошибки API, неожиданные форматы данных, отсутствие полей
  - Это ускоряет диагностику проблем при работе с API

## Следующие шаги (TODO)
Пользователь упомянул, что в следующем сообщении будут дополнительные вычисления, которые нужно реализовать.

## Зависимости
- httpx - для асинхронных HTTP запросов
- python-dotenv - для работы с .env файлами
- beautifulsoup4 - для парсинга HTML (мониторинг новостей)
- Pillow (>=10.0.0) - для генерации изображений таблиц арбитража (опционально, требуется для отправки изображений в Telegram)


## Логика работы бота

### Основная концепция
Бот определяет моменты времени для открытия и закрытия арбитражных позиций, используя два разных типа спредов:
- **Спред открытия позиции (max)** - для входа в арбитраж
- **Спред закрытия позиции (min)** - для выхода из арбитража

### Мониторинг спреда открытия позиции (max)

**Назначение:** Определить оптимальный момент для открытия Long и Short позиций на разных биржах.

**Что показывает:**
- Первое число - спред открытия между ask (биржа Long) и bid (биржа Short)
- Название монеты (для проверки)
- Ставка фандинга на бирже Long (long fr)
- Ставка фандинга на бирже Short (short fr)
- Разница между ставками фандинга (fr spread)

**Формула расчета спреда открытия (Откр (max)):**
```
Спред открытия = (bid_short - ask_long) / ask_long * 100
```
- **Положительное значение** = выгодный арбитраж (bid_short > ask_long)
- **Отрицательное значение** = невыгодно открывать
- Используется для определения момента входа в арбитраж

**Когда открывать:**
- Когда спред открытия достигает максимального значения (заданного порога, например 9.5%)
- Общий спред (спред на цену + спред на фандинг) должен быть положительным и достаточным для покрытия комиссий

**Пример:**
- На разнице в ценах: +1.77%
- На разнице в ставках фандинга: -0.75%
- Итого общий спред: ~1.02%

### Мониторинг спреда закрытия позиции (Закр (min))

**Назначение:** Определить оптимальный момент для закрытия Long и Short позиций (обратные сделки).

**Что показывает:**
- Спред закрытия между bid (биржа Long) и ask (биржа Short)
- Это обратные цены относительно открытия позиции
- Порог выхода (thr) - минимальный спред, при котором закрытие экономически оправдано

**Формула расчета спреда закрытия (Закр (min)):**
```
Спред закрытия = (bid_long - ask_short) / ask_short * 100
```
- **Положительное значение** = выгодно закрывать (bid_long > ask_short)
- **Отрицательное значение** = невыгодно закрывать (цены еще не сошлись)
- Используется для определения момента выхода из арбитража

**Порог выхода (thr):**
Порог выхода рассчитывается методом `get_exit_threshold_pct()` и учитывает:
- **Комиссия закрытия Long:** 0.04% (taker комиссия на бирже Long)
- **Комиссия закрытия Short:** 0.04% (taker комиссия на бирже Short)
- **Запас:** 0.10% (буфер для покрытия проскальзывания и других издержек)

**Формула порога выхода:**
```
Порог выхода = 0.04% + 0.04% + 0.10% = 0.18%
```

**Когда закрывать:**
- Когда спред закрытия (`Закр (min)`) достигает или превышает порог выхода (`thr = 0.18%`)
- Это означает, что закрытие покрывает все комиссии и запас, выход экономически оправдан
- **Условие:** `Закр (min) >= 0.18%` → можно закрывать позиции

### Ключевое различие между спредами

**Важно:** Спред открытия ≠ спред закрытия - это РАЗНЫЕ спреды!

**При открытии позиции:**
- Long: покупаем по **ask** на бирже A
- Short: продаем по **bid** на бирже B
- Спред = (bid_B - ask_A) / ask_A * 100
- Положительное значение = выгодно открывать (bid_B > ask_A)

**При закрытии позиции:**
- Long: продаем по **bid** на бирже A
- Short: покупаем по **ask** на бирже B
- Спред = (bid_A - ask_B) / ask_B * 100

Это важно, потому что при открытии и закрытии используются разные стороны стакана (ask/bid), поэтому спреды различаются.

### Расчет спредов

1. **Спред на цену (pr_spread):**
   
   **Общий спред на цену (для анализа арбитража):**
   - Формула: `(price_short - price_long) / price_long * 100`
   - Для схемы Long (A) / Short (B):
     - Положительный спред = хорошо (цена на Short бирже выше, можно продать дороже)
     - Отрицательный спред = плохо (цена на Short бирже ниже, продаем дешевле)
   - Используется для первоначального анализа арбитражной возможности
   
   **Спред для открытия позиции:**
   - Формула: `(ask_long - bid_short) / bid_short * 100`
   - Используется при мониторинге для определения момента входа
   
   **Спред для закрытия позиции:**
   - Формула: `(bid_long - ask_short) / ask_short * 100`
   - Используется при мониторинге для определения момента выхода

2. **Спред на фандинг (fr_spread / Net funding):**
   - Формула: `Net funding = funding_short - funding_long`
   - Экономическая логика funding:
     - Если funding > 0: Long платит, Short получает
     - Если funding < 0: Long получает, Short платит
   - PnL для позиций:
     - PnL Long = -funding_long
     - PnL Short = +funding_short
   - Net funding = PnL_long + PnL_short = funding_short - funding_long
   - Показывает чистый эффект по фандингу за один funding-период
   - Положительное значение = прибыль, отрицательное значение = убыток
   - **Пример:** Long: -2.0%, Short: -2.5% → Net funding = (-2.5%) - (-2.0%) = -0.5% (убыток)

3. **Общий спред (total_spread):**
   - pr_spread + fr_spread
   - Учитывает как разницу в ценах, так и разницу в фандингах

### Настройки бота

- **Алерт спред min (%)**: Порог для закрытия позиции (например, -1%)
  - Когда спред закрытия достигает этого значения, приходит оповещение
- **Алерт спред max (%)**: Порог для открытия позиции (например, 9.5%)
  - Когда спред открытия достигает этого значения, приходит оповещение

### Работа бота

1. Парсинг команды с размером инвестиций (обязательный параметр)
2. Получение данных о ценах и фандингах с бирж
3. Расчет спредов открытия и закрытия
4. Проверка ликвидности для указанного размера инвестиций
5. Проверка делистинга монеты на участвующих биржах
6. Проверка новостей о безопасности/взломах на участвующих биржах
7. Интерактивный промпт о ручном открытии позиций (если не отключен флагами)
8. Мониторинг спредов (если включен):
   - Бот каждую секунду запрашивает данные с бирж (цены ask/bid и фандинги)
   - Рассчитывает спреды открытия и закрытия
   - Выводит информацию в соответствующих окнах мониторинга
   - При достижении заданных порогов отправляет оповещения

### Неинтерактивный режим

Бот поддерживает неинтерактивный режим работы через командные флаги:

- `--no-monitor` - отключить мониторинг спредов (только анализ: спреды, ликвидность, делистинг, безопасность)
- `--no-prompt` - пропустить интерактивный промпт "Было ли ручное открытие позиций (long и short)?"
- `--monitor` - принудительно включить мониторинг спредов

**Примеры использования:**
```bash
# Только анализ без мониторинга и промпта
python bot.py "FLOW Long (binance), Short (gate) 33" --no-monitor --no-prompt

# Анализ + мониторинг, но без промпта
python bot.py "FLOW Long (binance), Short (gate) 33" --no-prompt

# Принудительно включить мониторинг (даже если есть другие флаги)
python bot.py "FLOW Long (binance), Short (gate) 33" --monitor
```

**Примечание:** Промпт также автоматически пропускается, если:
- `BOT_NO_PROMPT=1` установлен в переменных окружения
- `sys.stdin` не является TTY (терминалом)

### Формат вывода в логах мониторинга

В методе `monitor_spreads()` бот выводит информацию в следующем формате:

```
🚩 Закр: -4.27% (min: 0.18% цель: 0.80%) | ⛳ Откр: 3.92% | 📊 pr_spread: 3.9200 | 💰 fr_spread: 0.263 | 🎯 total_spread: 4.183 ⚙️ Long binance | Short bybit | ZKP
```

**Расшифровка:**
- **🚩 Закр:** Спред закрытия позиции, рассчитывается по формуле `(bid_long - ask_short) / ask_short * 100`
  - Положительное значение = выгодно закрывать
  - Отрицательное значение = невыгодно закрывать (цены еще не сошлись)
  - В скобках `(min: 0.18%)` указан минимальный порог выхода - минимальный спред, при котором закрытие экономически оправдано
  - В скобках `(цель: 0.80%)` указан порог закрытия для уведомлений в Telegram - если указан, сообщение отправляется когда `closing_spread <= цель`
  - **Условие для закрытия:** `Закр >= min` → можно закрывать позиции
- **⛳ Откр:** Спред открытия позиции, рассчитывается по формуле `(bid_short - ask_long) / ask_long * 100`
  - Положительное значение = выгодно открывать
  - Отрицательное значение = невыгодно открывать
- **📊 pr_spread:** Спред на цену (price spread) - тот же спред открытия, отображается с точностью до 4 знаков после запятой
- **💰 fr_spread:** Чистый эффект по фандингу, рассчитывается по формуле `funding_short - funding_long` (в процентах)
  - Положительное значение = прибыль от фандинга
  - Отрицательное значение = убыток от фандинга
- **🎯 total_spread:** Общий спред (total spread) - сумма спреда на цену и спреда на фандинги: `pr_spread + fr_spread`
  - Показывает общую прибыльность арбитража с учетом и ценового спреда, и фандинга
- **⚙️ Long {биржа} | Short {биржа} | {монета}:** Информация о биржах и монете

**Пример интерпретации:**
- `🚩 Закр: -4.27% (min: 0.18%)` - при закрытии будет убыток 4.27% из-за разницы цен (цены еще не сошлись). Минимальный порог 0.18% не достигнут, закрывать не стоит.
- `🚩 Закр: 0.25% (min: 0.18%)` - при закрытии будет прибыль 0.25% из-за разницы цен. Минимальный порог 0.18% достигнут, закрытие экономически оправдано.
- `⛳ Откр: 3.92%` - при открытии будет прибыль 3.92% из-за разницы цен
- `💰 fr_spread: 0.263` - за один funding-период будет прибыль 0.263% от фандинга
- `🎯 total_spread: 4.183` - общий спред (сумма спреда на цену и спреда на фандинги) составляет 4.183%

**Логика порога выхода:**
- Порог выхода (0.18%) учитывает комиссии закрытия обеих позиций (0.04% + 0.04%) и запас (0.10%)
- Когда `Закр (min) >= 0.18%`, закрытие покрывает все издержки и имеет смысл
- Если `Закр (min) < 0.18%`, закрытие не покрывает комиссии и запас, выход не оправдан

**Порог закрытия для уведомлений в Telegram:**
- При запуске мониторинга можно указать порог закрытия для уведомлений (например, `0.80%`)
- Если порог указан, сообщение в Telegram отправляется когда `closing_spread <= порог`
- Сообщения отправляются в `FREE_CHANNEL_ID` (независимо от `ENV`)
- Интервал между отправками: 1 минута (настраивается через `SEND_INTERVAL_SEC`)
- Формат сообщения:
  ```
  ⏰ Time to close CUDIS: Long (Gate) / Short (Mexc)
  🚩 Close: 0.57% (min: 0.18% цель: 0.80%)
  💰 Funding Spread: 0.004000%
  ```

### Пример работы

**Открытие позиции:**
- Найдена ситуация: GLM Long на MEXC, Short на Bybit
- Спред открытия достиг 9.5% → оповещение
- Открываем Long на MEXC (покупаем по ask) и Short на Bybit (продаем по bid) одновременно

**Закрытие позиции:**
- Мониторим спред закрытия
- Когда спред закрытия достигает порога для уведомлений (например, `<= 0.80%`) → отправляется сообщение в Telegram
- Закрываем Long на MEXC (продаем по bid) и Short на Bybit (покупаем по ask) одновременно

## Проверка делистинга

### Назначение
Бот автоматически проверяет наличие новостей о делистинге монеты на биржах, участвующих в арбитраже. Это критически важно, так как торговля делистированной монетой невозможна.

### Когда выполняется проверка
Проверка делистинга выполняется автоматически после получения базовой информации о монете (цены и фандинги), но до начала мониторинга спредов.

### Поддерживаемые биржи
- **Bybit** - через официальный API announcements
- **Gate.io** - через HTML-скрапинг страниц объявлений
- **MEXC** - через HTML-скрапинг страниц объявлений
- **XT.com** - через HTML-скрапинг страниц объявлений
- **Binance** - через HTML-скрапинг страниц объявлений
- **Bitget** - через HTML-скрапинг страниц объявлений
- **OKX** - через HTML-скрапинг страниц объявлений
- **BingX** - через HTML-скрапинг страниц объявлений

### Период поиска
По умолчанию проверяются объявления за последние **60 дней**. Это позволяет найти недавние делистинги, которые могли быть объявлены месяц назад.

### Как работает проверка

#### 1. Определение бирж для проверки
Бот проверяет делистинг только на тех биржах, которые участвуют в конкретном арбитраже.

**Пример:**
- Запрос: `"OBOL Long (bybit), Short (gate)"`
- Проверка делистинга выполняется только на **Bybit** и **Gate.io**

#### 2. Получение объявлений с бирж

**Bybit:**
- Используется официальный API: `GET /v5/announcements/index`
- Запрашиваются все объявления (без фильтров по типу/тегу) для избежания пропусков
- Локальная фильтрация по ключевым словам делистинга
- `locale=en-US`
- `limit=50` на страницу
- Данные получаются с пагинацией (до 50 страниц)
- Используется UTC для корректного сравнения дат
- Буфер 6 часов для предотвращения потери событий на границе периода

**Gate.io, MEXC, XT.com, Binance, Bitget, OKX, BingX:**
- Используется HTML-скрапинг страниц объявлений
- Парсятся заголовки и тексты объявлений
- Извлекаются ссылки на полные объявления
- Для повышения точности выполняется догруз полного контента статей, если монета упомянута или найдены ключевые слова делистинга
- Извлечение дат публикации из HTML (time, meta, JSON-LD) с нормализацией в UTC

#### 3. Поиск делистинга по монете

**Регулярное выражение для поиска монеты:**
- Ищет монету как отдельное слово: `OBOL`
- Ищет монету с суффиксом USDT: `OBOLUSDT`
- Учитывает, что фьючерсы торгуются только к USDT
- Пример регулярки: `(?<![A-Z0-9])OBOL(?:USDT)?(?![A-Z0-9])`

**Ключевые слова делистинга:**
- **Hard delisting (только эти используются):** "delist", "delisting", "removal", "removed", "discontinued", "terminated", "will be delisted", "to be delisted", "delisting announcement", "removal from trading", "cease trading"
- **Soft actions (не учитываются):** "trading suspended", "trading halt" - это временные паузы, а не делистинг
- **Русские:** "удаление", "делистинг", "прекращение торговли", "удаление с биржи", "прекращение листинга", "исключение из торговли"

**Условия для определения делистинга:**
1. Монета упомянута в заголовке или тексте объявления (как `OBOL` или `OBOLUSDT`)
2. В тексте присутствуют ключевые слова делистинга
3. Или в тегах объявления есть `SYMBOL_DELISTING`

#### 4. Обработка результатов

**Если делистинг найден:**
- Выводится предупреждение в лог: `⚠️ Найден делистинг {coin}: {title}... | URL: {url}`
- Показывается URL объявления для проверки деталей
- Бот продолжает работу, но пользователь предупрежден о риске

**Если делистинг не найден:**
- Выводится подтверждение: `✓ Новостей о делистинге {coin} ({exchanges}) за последние {days_back} дней не найдено`
- После проверки делистинга автоматически выполняется проверка новостей о безопасности/взломах
- Бот продолжает нормальную работу

### Технические детали

**Обработка дат:**
- Все даты обрабатываются в UTC для корректного сравнения
- Используется `datetime.now(timezone.utc)` для текущего времени
- Даты публикации парсятся с указанием timezone: `datetime.fromtimestamp(ms/1000, tz=timezone.utc)`
- Буфер 6 часов предотвращает потерю событий на границе периода (например, если делистинг был ровно 60 дней назад)

**Дедупликация:**
- Объявления дедуплицируются по URL (убираются query-параметры типа `utm_*`)
- Сохраняется порядок по дате публикации (новые → старые)

**Оптимизация:**
- Для Bybit используется ранняя остановка пагинации, если найдены объявления старше периода поиска
- Проверка выполняется только на биржах из запроса, что ускоряет работу

### Пример работы

**Запрос:** `"OBOL Long (bybit), Short (gate)"`

**Процесс:**
1. Получение данных о ценах и фандингах с Bybit и Gate.io
2. Автоматическая проверка делистинга OBOL на Bybit и Gate.io за последние 60 дней
3. Если найден делистинг:
   ```
   ⚠️ Найден делистинг OBOL: Delisting of OBOLUSDT Perpetual Contract... | URL: https://announcements.bybit.com/...
   ```
4. Если делистинг не найден:
   ```
   ✓ Новостей о делистинге OBOL за последние 60 дней не найдено
   ```

### Проверка доступности монеты

**Важно:** Если тикер не найден на бирже (API возвращает пустой результат), монета автоматически помечается как недоступная/делистированная:

- Выводится предупреждение: `⚠️ {coin} недоступна/делистирована на {exchange}`
- Выводится сообщение: `Арбитраж невозможен: тикер не найден на бирже Long/Short`
- Дальнейшая обработка арбитража прекращается
- Проверка делистинга не выполняется (так как монета уже недоступна)

## Проверка новостей о безопасности/взломах

### Назначение
Бот автоматически проверяет наличие новостей о безопасности, взломах, уязвимостях и других инцидентах, связанных с монетой на биржах, участвующих в арбитраже. Это критически важно для оценки рисков перед открытием позиций.

### Когда выполняется проверка
Проверка безопасности выполняется автоматически после проверки делистинга, но до начала мониторинга спредов. Проверяются только те биржи, которые участвуют в конкретном арбитраже.

### Поддерживаемые биржи
Проверка выполняется через модуль `announcements_monitor.py`, который использует `NewsMonitor` для получения объявлений со всех поддерживаемых бирж:
- **Bybit** - через официальный API announcements
- **Gate.io** - через HTML-скрапинг страниц объявлений
- **MEXC** - через HTML-скрапинг страниц объявлений
- **XT.com** - через HTML-скрапинг страниц объявлений
- **Binance** - через HTML-скрапинг страниц объявлений
- **Bitget** - через HTML-скрапинг страниц объявлений
- **OKX** - через HTML-скрапинг страниц объявлений
- **BingX** - через HTML-скрапинг страниц объявлений

### Период поиска
По умолчанию проверяются объявления за последние **60 дней**. Это позволяет найти недавние инциденты, которые могли быть объявлены месяц назад.

### Как работает проверка

#### 1. Определение бирж для проверки
Бот проверяет новости о безопасности только на тех биржах, которые участвуют в конкретном арбитраже.

**Пример:**
- Запрос: `"FLOW Long (binance), Short (gate) 33"`
- Проверка безопасности выполняется только на **Binance** и **Gate.io**

#### 2. Получение объявлений с бирж
Используется тот же механизм, что и для проверки делистинга (`NewsMonitor`), но без фильтрации по ключевым словам делистинга.

#### 3. Поиск новостей о безопасности по монете

**Регулярное выражение для поиска монеты:**
- Ищет монету как отдельное слово: `FLOW`
- Ищет монету с суффиксом USDT: `FLOWUSDT`
- Учитывает, что фьючерсы торгуются только к USDT
- Пример регулярки: `(?<![A-Z0-9])FLOW(?:USDT)?(?![A-Z0-9])`

**Ключевые слова безопасности:**
- **Английские:** "HACK", "EXPLOIT", "BREACH", "VULNERABILITY", "SECURITY", "COMPROMISE", "ATTACK", "STOLEN", "THEFT", "LEAK", "PRIVATE KEY", "KEY LEAK", "RISK WARNING", "SECURITY INCIDENT", "DYOR", "PROTOCOL"
- **Русские:** "ВЗЛОМ", "УЯЗВ", "ФИШИНГ", "КОМПРОМЕТ", "АТАК", "УКРАЛ", "КРАЖ", "УТЕЧК", "ВРЕДОНОС", "МОШЕННИЧ", "ПРЕДУПРЕЖДЕНИЕ О РИСК", "ИНЦИДЕНТ БЕЗОПАСНОСТ"

**Условия для определения новости о безопасности:**
1. Монета упомянута в заголовке или тексте объявления (как `FLOW` или `FLOWUSDT`)
2. В тексте присутствуют ключевые слова безопасности
3. Оба условия должны выполняться одновременно (строгое совпадение)

#### 4. Догруз полного контента статей
Для повышения точности выполняется догруз полного контента статей, если:
- Монета упомянута в карточке объявления, но ключевые слова безопасности не найдены
- Или ключевые слова безопасности найдены, но монета не упомянута в карточке

Это позволяет находить новости, где упоминание монеты или ключевые слова находятся только в теле статьи, а не в кратком описании.

#### 5. Обработка результатов

**Если новость о безопасности найдена:**
- Выводится предупреждение в лог: `⚠️ Security news для {coin}: {title}... | URL: {url}`
- Показывается URL объявления для проверки деталей
- Бот продолжает работу, но пользователь предупрежден о риске

**Если новость о безопасности не найдена:**
- Выводится подтверждение: `✓ Новостей о взломах/безопасности {coin} ({exchanges}) за последние {days_back} дней не найдено`
- Бот продолжает нормальную работу

### Технические детали

**Обработка дат:**
- Все даты обрабатываются в UTC для корректного сравнения
- Используется `datetime.now(timezone.utc)` для текущего времени
- Фильтрация по `days_back` выполняется после догруза полного контента и обновления дат публикации

**Кеширование:**
- Полный контент статей кешируется в памяти для избежания повторных запросов
- Если извлечение контента не удалось, в кеш записывается `None` (sentinel value)

**Оптимизация:**
- Ограничение на количество догружаемых статей (по умолчанию 20)
- Ранний skip статей с подтвержденной старой датой (до догруза)
- Проверка выполняется только на биржах из запроса, что ускоряет работу

### Пример работы

**Запрос:** `"FLOW Long (binance), Short (gate) 33"`

**Процесс:**
1. Получение данных о ценах и фандингах с Binance и Gate.io
2. Автоматическая проверка делистинга FLOW на Binance и Gate.io за последние 60 дней
3. Автоматическая проверка новостей о безопасности FLOW на Binance и Gate.io за последние 60 дней
4. Если найдена новость о безопасности:
   ```
   ⚠️ Security news для FLOW: Risk Warning: FLOW Protocol Security Incident... | URL: https://www.binance.com/...
   ```
5. Если новость о безопасности не найдена:
   ```
   ✓ Новостей о взломах/безопасности FLOW (binance, gate) за последние 60 дней не найдено
   ```

## Проверка ликвидности

### Назначение
Бот автоматически проверяет ликвидность на биржах перед открытием позиций. Это критически важно для оценки возможности выполнения сделок без значительного проскальзывания (slippage) и потери прибыли.

### Когда выполняется проверка
Проверка ликвидности выполняется автоматически после расчета спредов и перед проверкой делистинга. Проверяется ликвидность на обеих биржах (Long и Short) для размера сделки 150 USDT.

### Поддерживаемые биржи
- **Bybit** - через официальный API orderbook (`/v5/market/orderbook`)
- **Gate.io** - через официальный API orderbook (`/api/v4/futures/usdt/order_book`)
- **MEXC** - через официальный API orderbook (`/api/v1/contract/depth/{symbol}`)
- **XT.com** - через официальный API orderbook (`/future/market/v1/public/cg/orderbook`)
- **LBank** - через официальный API orderbook (`/cfd/openApi/v1/pub/depth`)
- **Binance** - через официальный API orderbook (`/fapi/v1/depth`)

### Размер сделки
Проверка выполняется для размера, указанного в команде (например, `100` для команды `"FLOW Long (binance), Short (gate) 100"`). Размер обязателен и используется для обеих позиций (Long и Short). Это позволяет оценить ликвидность для конкретного размера инвестиций, а не фиксированного значения.

### Единицы измерения: BPS (Basis Points)

Все параметры ликвидности измеряются в **bps (basis points)** - базовых пунктах.

**Определение:**
- **1 bps = 0.01% = 1/100 процента**
- **100 bps = 1%**

**Примеры:**
- `spread=48.4bps` означает спред **0.484%**
- `buy_impact=25.1bps` означает проскальзывание при покупке **0.251%**
- `sell_impact=8.8bps` означает проскальзывание при продаже **0.088%**

**Почему используют bps?**
- Удобнее для малых значений: вместо "0.484%" проще сказать "48.4 bps"
- Стандартная единица измерения в трейдинге и финансах
- Позволяет точно выражать малые проценты без десятичных дробей

**В контексте ликвидности:**
- **spread (bps)** - разница между лучшим bid и ask в стакане. Чем больше, тем хуже ликвидность (больше стоимость входа/выхода)
- **buy_impact (bps)** - проскальзывание при покупке указанного объёма. Чем больше, тем хуже ликвидность на стороне покупки
- **sell_impact (bps)** - проскальзывание при продаже указанного объёма. Чем больше, тем хуже ликвидность на стороне продажи

### Проверяемые параметры

#### 1. Top-of-book спред (Spread)
**Что проверяется:** Разница между лучшей ценой покупки (ask1) и лучшей ценой продажи (bid1) на первом уровне стакана.

**Формула:**
```
spread_bps = (ask1 - bid1) / mid * 10_000
```
где `mid = (bid1 + ask1) / 2.0`

**Порог:** ≤ 30 bps (0.30%)
- Если спред больше 30 bps, ликвидность считается недостаточной
- Большой спред означает высокую стоимость входа/выхода

#### 2. Глубина до размера сделки (Price Impact / Slippage)
**Что проверяется:** Эффективный проскальзывание при выполнении сделки заданного размера (VWAP - Volume Weighted Average Price).

**Метод расчета:**
1. Берется книга заявок (orderbook) с 50 уровнями
2. Рассчитывается VWAP для покупки (используя asks) и продажи (используя bids)
3. Вычисляется отклонение VWAP от top-of-book цены (ask1 для покупки, bid1 для продажи)

**Важно:** Impact считается относительно top-of-book, а не mid, чтобы разделить spread и impact:
- **Spread** = разница между ask1 и bid1 (стоимость входа из-за спреда)
- **Impact** = дополнительная потеря из-за глубины стакана (проскальзывание)

**Формула для buy impact:**
```
buy_impact_bps = |buy_vwap - ask1| / mid * 10_000
```
где `ask1` - лучшая цена продажи на первом уровне

**Формула для sell impact:**
```
sell_impact_bps = |bid1 - sell_vwap| / mid * 10_000
```
где `bid1` - лучшая цена покупки на первом уровне

**Порог:** ≤ 50 bps (0.50%) на сторону
- Рекомендуется ≤ 30 bps для лучшей ликвидности
- 50 bps - компромиссный вариант для реальных рынков
- Если проскальзывание больше порога, ликвидность недостаточна для размера сделки

#### 3. Достаточность объема (Depth)
**Что проверяется:** Хватает ли объема в стакане для выполнения сделки заданного размера.

**Метод:**
- Проверяется, можно ли купить/продать нужный номинал (указанный в команде) в пределах 50 уровней стакана
- Если объема не хватает, VWAP не может быть рассчитан (возвращается `None`)

**Порог:** Должно хватать объема для полного номинала сделки

### Пороговые значения

**Рекомендуемые пороги (независимо от размера сделки):**
- **max_spread_bps**: 30 (0.30%)
- **max_impact_bps**: 50 (0.50%) - компромиссный вариант
  - Лучше: 30 bps (0.30%) для более строгой проверки
- **orderbook_limit**: 50 уровней
  - Если часто "не хватает глубины", можно увеличить до 200 уровней

**Примечание:** Пороги одинаковы для любого размера сделки. Если вы проверяете ликвидность для 30-100 USDT, но анализ выполнен для 150 USDT, это даст более консервативную оценку (если для 150 USDT ликвидность достаточна, то для меньших размеров она также будет достаточна).

### Как работает проверка

#### 1. Получение orderbook
- Запрашивается книга заявок через API: `GET /v5/market/orderbook?category=linear&symbol=GPSUSDT&limit=50`
- Получаются списки bids (заявки на покупку) и asks (заявки на продажу)

#### 2. Режимы проверки
Проверка ликвидности может выполняться в трех режимах:

- **`entry_long`** - проверка для входа в Long позицию
  - Важна только глубина на покупку (`buy_vwap`)
  - Проверяется только `buy_impact_bps`
  - Используется для Long биржи
  
- **`entry_short`** - проверка для входа в Short позицию
  - Важна только глубина на продажу (`sell_vwap`)
  - Проверяется только `sell_impact_bps`
  - Используется для Short биржи
  
- **`roundtrip`** - проверка для полного цикла (вход + выход)
  - Нужны оба: `buy_vwap` и `sell_vwap`
  - Проверяются оба impact
  - Используется по умолчанию

**Логика:** В режиме `entry_long` не нужно заваливать проверку из-за большого `sell_impact`, так как входим только в Long. Аналогично для `entry_short`.

#### 3. Расчет метрик

**Спред:**
```
spread_bps = (ask1 - bid1) / mid * 10_000
```
где `mid = (bid1 + ask1) / 2.0`

**Расчет VWAP (Volume Weighted Average Price):**

Алгоритм расчета VWAP для заданного номинала:
1. Итерация по уровням стакана (asks для покупки, bids для продажи)
2. Для каждого уровня:
   - Вычисляется номинал уровня: `level_notional = price * size`
   - Берется нужное количество: `take = min(level_notional, remaining)`
   - Конвертируется в базовую монету: `take_sz = take / price`
   - Накопление: `filled_usdt += take`, `filled_base += take_sz`
   - Остаток: `remaining -= take`
3. Если `remaining <= 1e-9` - глубина достаточна
4. Если `remaining > 1e-6` - глубина недостаточна, возвращается `(None, filled_usdt)`
5. Расчет VWAP: `vwap = filled_usdt / filled_base`

**Buy VWAP:** Рассчитывается для покупки заданного номинала по asks (сверху вниз)
**Sell VWAP:** Рассчитывается для продажи заданного номинала по bids (сверху вниз)

**Buy Impact:**
```
buy_impact_bps = |buy_vwap - ask1| / mid * 10_000
```
Отклонение от лучшей цены продажи (ask1)

**Sell Impact:**
```
sell_impact_bps = |bid1 - sell_vwap| / mid * 10_000
```
Отклонение от лучшей цены покупки (bid1)

#### 4. Проверка условий
Проверка считается успешной (`ok = True`), если:
- Спред ≤ 30 bps
- Глубины хватает для нужной стороны:
  - `entry_long`: `buy_vwap is not None`
  - `entry_short`: `sell_vwap is not None`
  - `roundtrip`: оба `buy_vwap` и `sell_vwap` не None
- Impact для нужной стороны ≤ 50 bps:
  - `entry_long`: только `buy_impact_bps ≤ 50 bps`
  - `entry_short`: только `sell_impact_bps ≤ 50 bps`
  - `roundtrip`: оба impact ≤ 50 bps

Если хотя бы одно условие не выполнено, проверка считается неуспешной (`ok = False`).

### Вывод результатов

**Успешная проверка:**
```
✓ Ликвидность bybit Long (GPS): 100.0 USDT | spread=15.2bps, buy_impact=25.1bps
```

**Неуспешная проверка:**
```
✗ Ликвидность bybit Long (GPS): 100.0 USDT | spread=45.3bps, buy_impact=65.2bps
  Причины: spread 45.3 bps > 30.0, buy impact 65.2 bps > 50.0
```

**Примечание:** Размер в логе соответствует размеру, указанному в команде (например, `100` для `"FLOW Long (binance), Short (gate) 100"`).

### Почему это важно

**24h volume не гарантирует ликвидность:**
- Большой дневной объем не означает, что прямо сейчас на top-of-book есть достаточная глубина
- VWAP/impact по orderbook - самый прямой тест "хватит ли ликвидности для входа/выхода без убийства PnL"

**Преимущества проверки:**
- Показывает реальную стоимость входа/выхода (проскальзывание)
- Предотвращает открытие позиций на рынках с низкой ликвидностью
- Помогает оценить возможность выполнения сделки размером 150 USDT

### Технические детали

**API эндпоинты для orderbook:**

**Bybit:**
- `GET /v5/market/orderbook`
- Параметры: `category=linear`, `symbol=COINUSDT`, `limit=50`
- Возвращает: `{"retCode": 0, "result": {"b": [[price, size], ...], "a": [[price, size], ...]}}`

**Gate.io:**
- `GET /api/v4/futures/usdt/order_book`
- Параметры: `contract=COIN_USDT`, `limit=50`
- Возвращает: `{"bids": [[price, size], ...], "asks": [[price, size], ...]}`

**MEXC:**
- `GET /api/v1/contract/depth/{symbol}`
- Параметры: `{symbol}` в path (например, `/api/v1/contract/depth/DN_USDT`), `limit=50` в query (от 1 до 200)
- Возвращает: `{"code": 0, "data": {"bids": [[price, size], ...], "asks": [[price, size], ...]}}`
- **ВАЖНО:** Символ должен быть в path, а не в query параметрах

**XT.com:**
- `GET /future/market/v1/public/cg/orderbook`
- Параметры: `symbol=coin_usdt`, `level=50` (level ограничен от 1 до 200)
- Возвращает: `{"bids": [[price, size], ...], "asks": [[price, size], ...]}`

**LBank:**
- `GET /cfd/openApi/v1/pub/depth`
- Параметры: `productGroup=SwapU`, `symbol=COINUSDT`, `limit=50`
- Возвращает: `{"data": {"bids": [[price, size], ...], "asks": [[price, size], ...]}}`

**Binance:**
- `GET /fapi/v1/depth`
- Параметры: `symbol=COINUSDT`, `limit=50` (limit от 5 до 5000)
- Возвращает: `{"bids": [[price, size], ...], "asks": [[price, size], ...]}`

**Расчет VWAP (детально):**

Метод `_vwap_for_notional()` выполняет следующие шаги:

1. **Инициализация:**
   - `remaining = target_usdt` (целевой номинал в USDT)
   - `filled_usdt = 0.0` (накопленный номинал)
   - `filled_base = 0.0` (накопленное количество базовой монеты)

2. **Итерация по уровням стакана:**
   - Для каждого уровня `[price, size]`:
     - `level_notional = price * size` (номинал уровня в USDT)
     - `take = min(level_notional, remaining)` (сколько берем с этого уровня)
     - `take_sz = take / price` (количество базовой монеты)
     - `filled_usdt += take`
     - `filled_base += take_sz`
     - `remaining -= take`
     - Если `remaining <= 1e-9` → глубина достаточна, выходим

3. **Проверка результата:**
   - Если `filled_base <= 0` → возвращается `(None, 0.0)`
   - Если `remaining > 1e-6` → глубина недостаточна, возвращается `(None, filled_usdt)`
   - Иначе: `vwap = filled_usdt / filled_base`, возвращается `(vwap, target_usdt)`

**Обработка недостаточной глубины:**
- Если объема не хватает, `vwap = None`
- В лог выводится информация о том, сколько USDT удалось "заполнить" (`filled_usdt`)
- Сообщение формируется в зависимости от режима:
  - `entry_long`: показывает только `buy_filled`
  - `entry_short`: показывает только `sell_filled`
  - `roundtrip`: показывает оба `buy_filled` и `sell_filled`

**Валидация режима:**
- Если передан неверный `mode` (не `entry_long`, `entry_short`, `roundtrip`), выводится предупреждение и используется `roundtrip` по умолчанию

### Пример работы

**Запрос:** `"GPS Long (bybit), Short (xt)"`

**Процесс:**
1. Получение данных о ценах и фандингах с Bybit и XT
2. Расчет спредов
3. Автоматическая проверка ликвидности на Bybit (Long) и XT (Short) для размера, указанного в команде
4. Вывод результатов:
   ```
   ✅ Ликвидность bybit Long (GPS): 100.0 USDT | spread=12.5bps, buy_impact=22.1bps
   ✅ Ликвидность xt Short (GPS): 100.0 USDT | spread=10.0bps, sell_impact=18.3bps
   ```
5. Если ликвидность недостаточна:
   ```
   ❌ Ликвидность bybit Long (GPS): 100.0 USDT | spread=45.2bps, buy_impact=68.5bps
     Причины: spread 45.2 bps > 30.0, buy impact 68.5 bps > 50.0
   ```

## Автоматическое обнаружение монет и сканирование спредов

### Назначение
Модуль `coin_list_fetchers.py` и скрипт `scan_spreads.py` обеспечивают автоматическое обнаружение всех доступных монет на фьючерсах для каждой биржи и непрерывное сканирование арбитражных возможностей между всеми парами бирж.

### Архитектура

#### 1. Модуль `coin_list_fetchers.py`
Централизованный модуль для получения списка всех доступных монет на USDT-M perpetual для каждой биржи.

**Основные функции:**
- `fetch_bybit_coins(exchange)` - получение монет с Bybit
- `fetch_gate_coins(exchange)` - получение монет с Gate.io
- `fetch_mexc_coins(exchange)` - получение монет с MEXC
- `fetch_xt_coins(exchange)` - получение монет с XT.com
- `fetch_binance_coins(exchange)` - получение монет с Binance
- `fetch_bitget_coins(exchange)` - получение монет с Bitget
- `fetch_okx_coins(exchange)` - получение монет с OKX
- `fetch_bingx_coins(exchange)` - получение монет с BingX
- `fetch_lbank_coins(exchange)` - получение монет с LBank

**Возвращаемое значение:**
- Все функции возвращают `Set[str]` - множество монет без суффиксов (например, `{"BTC", "ETH", "SOL", ...}`)
- Монеты приводятся к верхнему регистру (`.upper()`)

**Интеграция:**
- Каждый класс биржи (`AsyncBybitExchange`, `AsyncGateExchange`, и т.д.) реализует метод `get_all_futures_coins() -> Set[str]`
- Метод вызывает соответствующую функцию из `coin_list_fetchers.py`
- Это обеспечивает единообразный интерфейс для всех бирж

#### 2. Скрипт `scan_spreads.py`
Непрерывное сканирование арбитражных возможностей между всеми парами бирж.

**Основные компоненты:**

**A) Сбор монет по биржам:**
```python
async def collect_coins_by_exchange(bot, exchanges) -> Dict[str, Set[str]]
```
- Собирает список монет для каждой биржи параллельно
- Возвращает словарь `{exchange_name: set_of_coins}`
- Обрабатывает ошибки (пустые наборы для бирж с ошибками)

**B) Построение union:**
```python
def build_union(coins_by_exchange) -> List[str]
```
- Строит union всех монет со всех бирж
- Возвращает отсортированный список уникальных монет

**C) Сканирование одной монеты:**
```python
async def scan_coin(bot, coin, coins_by_exchange, exchanges) -> List[Tuple]
```
- Определяет биржи, где монета реально есть (из `coins_by_exchange`)
- Запрашивает данные только с этих бирж (убирает "шум" ошибок)
- Вычисляет спреды для всех пар доступных бирж
- Возвращает список найденных возможностей

**D) Батчинг и параллелизм:**
```python
async def scan_once(bot, exchanges, coins, coins_by_exchange) -> List[Tuple]
```
- Обрабатывает монеты батчами (по умолчанию 50 монет за раз)
- Параллельно обрабатывает монеты внутри батча
- Ограничивает параллелизм через семафор (по умолчанию 40 одновременных запросов)
- Выводит прогресс после каждого батча: `scan progress: 50/858 coins`

**E) Улучшенная обработка запросов:**
```python
async def fetch(bot, ex, coin, sem):
    # 1) Тикер (критично для спреда): ретраи при timeout
    ticker = await exchange.get_futures_ticker(coin)
    # 2) Funding (не критично): таймаут не должен "убивать" тикер
    funding = await exchange.get_funding_rate(coin)  # опционально
```
- **Тикер и funding запрашиваются отдельно** для лучшей обработки ошибок
- **Если funding завис/затупил — возвращается тикер**, чтобы не терять данные по монете
- **Ретраи для тикера** при `TimeoutError` (настраивается через `SCAN_FETCH_RETRIES`)
- **Семафор держится только во время реального HTTP**, не во время sleep/backoff (предотвращает накопление очереди)
- **Отдельные таймауты** для тикера и funding (настраиваются через `SCAN_TICKER_TIMEOUT_SEC`, `SCAN_FUNDING_TIMEOUT_SEC`)
- Предотвращает перегрузку API rate-limit через `SCAN_MAX_CONCURRENCY` (по умолчанию 40)

**F) Глубокий анализ найденных спредов:**
```python
async def _analyze_and_log_opportunity(bot, coin, long_ex, short_ex, spread, analysis_sem, long_data, short_data):
    # 1) Ликвидность (orderbook VWAP)
    # 2) Новости (делистинг + безопасность, с кешем 3 минуты)
    # 3) Вердикт: ✓ арбитражить или ✗ не арбитражить
```
- Для каждой найденной связки выполняется **полный анализ** (как в `bot.py`): ликвидность + новости
- **Кеш новостей на 3 минуты** по ключу `(coin, long_ex, short_ex)` для избежания повторных запросов
  - **UPD:** кеш переведен на ключ `(coin, exchange)`, чтобы переиспользовать результаты между разными парами бирж
    (пример: BTC-bybit + BTC-binance → для BTC-bybit+gate докачиваем только BTC-gate)
- **Вердикт выставляется автоматически** на основе результатов анализа
- **Telegram уведомления** отправляются только для вердикта "✅ арбитражить"
- Параллелизм анализа ограничен через `SCAN_ANALYSIS_MAX_CONCURRENCY` (по умолчанию 2)

#### 3. Скрипт `one_coin_bot.py`
Анализ одной монеты на всех доступных биржах.

**Основные компоненты:**

**A) Определение доступных бирж:**
```python
async def _collect_supported_exchanges(bot, coin) -> List[str]
```
- Проверяет наличие монеты на всех биржах (кроме LBank) через `get_all_futures_coins()`
- Возвращает список бирж, где монета доступна
- Молча пропускает биржи, где монеты нет (без логов)
- Логирует ошибки при запросе списка монет

**B) Получение данных с бирж:**
```python
async def fetch_exchange_data(bot, ex, coin, sem) -> Dict[str, Any]
```
- Параллельно запрашивает цены (ticker) и фандинги со всех доступных бирж
- Использует те же таймауты и ретраи, что и `scan_spreads.py`
- Возвращает словарь с `price`, `bid`, `ask`, `funding_rate` (если доступны)
- Ошибки логируются, но не прерывают выполнение

**C) Анализ пары бирж:**
```python
async def _analyze_pair_line(bot, coin, long_ex, short_ex, data_by_ex, analysis_sem) -> str
```
- Для каждой пары бирж (Long на одной, Short на другой) выполняет:
  - Вычисление спреда цены и фандинга
  - Проверку ликвидности для суммы `SCAN_COIN_INVEST` (по умолчанию **50 USDT** на каждую позицию: Long и Short) с параметрами `max_spread_bps=30.0`, `max_impact_bps=50.0`
  - Проверку новостей (делистинг и безопасность за 60 дней, с кешем)
  - Определение вердикта (✅ арбитражить / ❌ не арбитражить)
- Формирует строку вывода в формате: `📈 Long {биржа} Ц/Ф: {цена} / {фандинг}% | 📉 Short {биржа} Ц/Ф: {цена} / {фандинг}% | 📊 Спред Ц/Ф: {спред_цены}% / {спред_фандинга}% | {вердикт} {причины}`
- При ошибке в проверке ликвидности/новостей: логирует ошибку и возвращает строку без вердикта

**D) Вывод результатов:**
- Результаты выводятся по мере обработки пар (без сортировки)
- Использует отдельный лог-файл (`SCAN_LOG_FILE` из .env, по умолчанию `scan_one_coin.log`)
- Заголовок: "Анализ монеты {COIN}"
- **Сумма инвестиций для проверки ликвидности:** Используется значение из `SCAN_COIN_INVEST` (по умолчанию **50 USDT**). Эта сумма применяется для каждой позиции (Long и Short) при проверке ликвидности через orderbook VWAP

**Использование:**
```bash
python one_coin_bot.py CLO
```

**Особенности:**
- Переиспользует логику проверки ликвидности и новостей из `scan_spreads.py`
- Параллельная обработка всех пар бирж
- Автоматическое определение доступных бирж для монеты
- Показывает все возможные комбинации Long/Short для указанной монеты

**Формат вывода:**
```
Анализ монеты DN (инвестиции: 50 USDT на позицию)
📈 Long gate Ц/Ф: 1.232 / -1.170% | 📉 Short mexc Ц/Ф: 1.25 / 0.013% | 📊 Спред Ц/Ф/О: 1.055% / 1.183% / 2.238% | ✅ арбитр (gate: 40.584 DN, mexc: 40.000 DN)
📈 Long gate Ц/Ф: 1.232 / -1.170% | 📉 Short bingx Ц/Ф: 1.231 / 0.009% | 📊 Спред Ц/Ф/О: -0.073% / 1.179% / 1.106% | ❌ не арбитр (спред -0.073% < 2.0%)
📈 Long mexc Ц/Ф: 1.25 / 0.013% | 📉 Short gate Ц/Ф: 1.232 / -1.170% | 📊 Спред Ц/Ф/О: -1.440% / -1.183% / -2.623% | ❌ не арбитр (ликв. Long: ask1: 1.25 bid1: 1.248 spread 48.4 bps > 30.0)
📈 Long mexc Ц/Ф: 1.25 / 0.013% | 📉 Short bingx Ц/Ф: 1.231 / 0.009% | 📊 Спред Ц/Ф/О: -1.520% / -0.004% / -1.524% | ❌ не арбитр (спред -1.520% < 2.0%; делистинг)
```

**Расшифровка формата:**
- **📈 Long {биржа} Ц/Ф:** Цена и фандинг на бирже для Long позиции (Ц/Ф = Цена/Фандинг)
- **📉 Short {биржа} Ц/Ф:** Цена и фандинг на бирже для Short позиции
- **📊 Спред Ц/Ф/О:** Спред на цену, спред на фандинги и общий спред (Ц/Ф/О = Цена/Фандинг/Общий)
  - **Ц** - спред на цену (price spread)
  - **Ф** - спред на фандинги (funding spread)
  - **О** - общий спред (total spread = price spread + funding spread)
- **Вердикт:** `✅ арбитр` или `❌ не арбитр`
- **Количества монет:** Если вердикт `✅ арбитр`, в скобках выводятся количества монет, которые можно купить на каждой бирже за `SCAN_COIN_INVEST` (например, `(gate: 40.584 DN, mexc: 40.000 DN)`)
- **Причины отказа:** Выводятся в скобках после вердикта "❌ не арбитр", аналогично `scan_spreads.py`:
  - `(спред X% < Y%)` - если спред цены меньше MIN_SPREAD
  - `(ликв. Long: {причина})` - проблемы с ликвидностью на Long бирже
  - `(ликв. Short: {причина})` - проблемы с ликвидностью на Short бирже
  - `(делистинг)` - найдены новости о делистинге
  - `(безопасность)` - найдены новости о безопасности/взломах
  - Несколько причин объединяются через `; `

### Настройки через .env

**Все параметры конфигурации:**

```env
# Файл лога для основного бота (bot.py)
LOG_FILE=arbitrage_perp_bot.log

# Уровень логирования для основного бота (DEBUG, INFO, WARNING, ERROR)
LOG_LEVEL=INFO

# Минимальный спред в процентах для вывода находок в scan_spreads.py
# Находки со спредом меньше этого значения не будут логироваться
MIN_SPREAD=2

# Интервал между полными сканами всех монет в секундах
# После завершения одного прохода скрипт ждёт это время перед следующим
SCAN_INTERVAL_SEC=5

# Таймаут на запрос к бирже в секундах (общий, используется как fallback)
# Если запрос не завершится за это время, он будет прерван и залогирован как timeout
# Рекомендуемые значения: 8-12 секунд
SCAN_REQ_TIMEOUT_SEC=12

# Таймаут только на ticker (сек)
# Тикер критичен для расчета спреда, поэтому имеет отдельный таймаут
SCAN_TICKER_TIMEOUT_SEC=12

# Таймаут только на funding (сек)
# Funding не критичен для расчета спреда цены, таймаут не должен "убивать" тикер
SCAN_FUNDING_TIMEOUT_SEC=12

# Количество дополнительных попыток на ticker при timeout (0-2 разумно)
# При timeout тикера выполняется повторная попытка с backoff
SCAN_FETCH_RETRIES=1

# Backoff между попытками ticker (сек)
# Время ожидания перед повторной попыткой получения тикера
SCAN_FETCH_RETRY_BACKOFF_SEC=0.6

# Максимальное количество одновременных HTTP запросов к биржам
# Ограничивает параллелизм для предотвращения rate-limit
# Рекомендуемые значения: 20-40 (при проблемах снизить до 20-30, при стабильности можно поднять до 60-80)
SCAN_MAX_CONCURRENCY=40

# Размер позиции (USDT) для проверки ликвидности в сканере
# Используется для анализа ликвидности найденных спредов (для каждой позиции: Long и Short)
SCAN_COIN_INVEST=50

# Параллелизм "глубокого" анализа спредов (ликвидность + новости)
# Ограничивает количество одновременных анализов найденных спредов
# Рекомендуемые значения: 1-3 (слишком высокий может перегрузить API новостей)
SCAN_ANALYSIS_MAX_CONCURRENCY=2

# TTL кеша новостей (сек), по умолчанию 3 минуты
# Кеш новостей по ключу (coin, exchange) для избежания повторных запросов
# (переиспользуется между разными парами бирж: BTC-bybit + BTC-binance -> для BTC-bybit+gate докачиваем только BTC-gate)
SCAN_NEWS_CACHE_TTL_SEC=180

# Размер батча монет для обработки
# Количество монет, обрабатываемых за один батч
SCAN_COIN_BATCH_SIZE=50

# Файл лога для скрипта scan_spreads.py
# Файл лога для скриптов scan_spreads.py и one_coin_bot.py
# Для scan_spreads.py используется по умолчанию, если не указан
# Для one_coin_bot.py используется всегда (по умолчанию scan_one_coin.log)
SCAN_LOG_FILE=scan_spreads.log

# Уровень логирования для scan_spreads.py (DEBUG, INFO, WARNING, ERROR)
SCAN_LOG_LEVEL=INFO
```

**Настройка под нагрузку:**
- Если начинаются rate-limit / timeouts → снизить `SCAN_MAX_CONCURRENCY` до 20-30
- Если всё стабильно → можно поднять до 60-80 (аккуратно)
- При проблемах с таймаутами тикера → увеличить `SCAN_TICKER_TIMEOUT_SEC` до 15-20 секунд или `SCAN_FETCH_RETRIES` до 2
- При большом количестве монет (800+) можно увеличить `SCAN_COIN_BATCH_SIZE` до 100
- При частых таймаутах funding → можно уменьшить `SCAN_FUNDING_TIMEOUT_SEC` до 8-10 секунд (funding не критичен для расчета спреда цены)

### Логика работы

#### 1. Инициализация
1. Собираются монеты для каждой биржи параллельно
2. Строится union всех монет
3. Выводится статистика: количество монет на каждой бирже и общее количество

#### 2. Цикл сканирования
1. Перед каждым циклом обновляется список монет со всех бирж (периодический refresh)
2. Выводится лог: `🔄 Новый цикл поиска`
3. Монеты обрабатываются батчами (по умолчанию 50)
4. Для каждой монеты:
   - Определяются биржи, где монета реально есть
   - Запрашиваются данные только с этих бирж (убирает "шум")
   - Тикер и funding запрашиваются отдельно (если funding завис — тикер всё равно возвращается)
   - Вычисляются спреды для всех пар бирж
5. Для каждой найденной связки со спредом >= MIN_SPREAD:
   - Выполняется **глубокий анализ**: ликвидность (orderbook VWAP) + новости (делистинг + безопасность)
   - Новости кешируются на 3 минуты по ключу `(coin, exchange)` (переиспользуется между разными парами бирж)
   - Выставляется вердикт: `✓ арбитражить` или `✗ не арбитражить`
   - Выводится одна строка: `💰 {coin} Long ({long_ex}), Short ({short_ex}) spread {spread:.3f}% | fund {funding_spread:.3f} {verdict} {reasons}`
   - Если вердикт "✅ арбитражить" — отправляется сообщение в Telegram (если включено)
6. После каждого батча выводится прогресс: `Progress: {processed}/{total} coins processed`
7. После завершения цикла выводится время выполнения: `scan_once finished in {time:.1f}s; sleeping {interval:.1f}s`

#### 3. Преимущества новой логики

**Устранение "шума":**
- Запросы выполняются только к биржам, где монета реально есть
- Убираются предупреждения "инструмент не найден" для монет, которых нет на бирже
- Снижается количество бесполезных запросов в разы

**Устранение "зависания":**
- Батчинг позволяет видеть прогресс после каждой пачки монет
- Параллелизм ускоряет обработку
- Прогресс-логи показывают, что скрипт работает

**Оптимизация производительности:**
- Ограничение параллелизма предотвращает перегрузку API
- Батчинг позволяет контролировать нагрузку
- Обработка только общих монет для пар бирж снижает количество запросов
- **Кеш новостей на 3 минуты** по ключу `(coin, exchange)` для избежания повторных запросов и переиспользования между разными парами бирж
- **Тикер и funding запрашиваются отдельно** — если funding завис, тикер всё равно возвращается (не теряем данные по монете)
- **Семафор держится только во время реального HTTP**, не во время sleep/backoff (предотвращает накопление очереди)

### API endpoints для получения списка монет

**Bybit:**
- Endpoint: `/v5/market/instruments-info`
- Параметры: `category=linear`, `limit=1000`, `cursor` (пагинация)
- Фильтры: `quoteCoin="USDT"`, `settleCoin="USDT"`, `status="Trading"`, `contractType="LinearPerpetual"`
- Формат ответа: `{"retCode": 0, "result": {"list": [...], "nextPageCursor": "..."}}`

**Gate.io:**
- Endpoint: `/api/v4/futures/usdt/contracts`
- Фильтры: `name.endswith("_USDT")`, `in_delisting is not True`, `trade_status` не в `("delisting", "suspend", "suspended", "closed")`
- Формат ответа: список объектов с полем `name`

**MEXC:**
- Endpoint: `/api/v1/contract/detail`
- Фильтры: `symbol.endswith("_USDT")`, `state` не в `("3", "4", "5")`
- Формат ответа: `{"code": 0, "data": [...]}`

**XT.com:**
- Endpoint: `/future/market/v1/public/cg/contracts`
- Базовый URL: `https://fapi.xt.com` (отдельный домен для фьючерсов)
- Формат ответа: список объектов или `{"returnCode": 0, "result": [...]}`
- Символы: `symbol` или `contractCode` в формате `btc_usdt` (lowercase с подчеркиванием)

**Binance:**
- Endpoint: `/fapi/v1/exchangeInfo`
- Фильтры: `contractType="PERPETUAL"`, `quoteAsset="USDT"`, `status="TRADING"`
- Формат ответа: `{"symbols": [...]}`

**Bitget:**
- Endpoint: `/api/v2/mix/market/tickers`
- Параметры: `productType=USDT-FUTURES`
- Формат ответа: `{"code": "00000", "data": [...]}`
- Символы: `symbol` в формате `BTCUSDT` (может быть суффикс `_UMCBL`, который удаляется)

**OKX:**
- Endpoint: `/api/v5/public/instruments`
- Параметры: `instType=SWAP`
- Фильтры: `settleCcy="USDT"`, `instId.endswith("-USDT-SWAP")`, `state="live"`
- Формат ответа: `{"code": "0", "data": [...]}`

**BingX:**
- Endpoint: `/openApi/swap/v2/quote/contracts`
- Фильтры: `symbol.endswith("-USDT")`
- Формат ответа: `{"code": 0, "data": [...]}`

**LBank:**
- Использует кешированный список инструментов через `exchange._get_instruments_with_cache()`
- Фильтры: применяется канонизация символов через `exchange._canon()`
- Формат ответа: зависит от внутреннего API биржи

### Пример работы

**Инициализация:**
```
Всего монет (union по биржам): 858
bybit: 450 монет
gate: 320 монет
mexc: 280 монет
xt: 150 монет
binance: 380 монет
bitget: 290 монет
okx: 420 монет
bingx: 200 монет

scan_spreads started | MIN_SPREAD=2.00% | interval=5s | exchanges=['bybit', 'gate', ...] | total_coins=858 | batch=50 | max_concurrency=40
```

**Прогресс сканирования:**
```
scan progress: 50/858 coins
scan progress: 100/858 coins
scan progress: 150/858 coins
...
```

**Найденные возможности:**
```
💰 BTC Long (gate), Short (bingx) Спред на цену: 2.346% | Фандинг: 0.004% | Спред общий: 2.350% ✅ арбитражить (gate: 1.234 BTC, bingx: 1.230 BTC)
💰 ETH Long (bybit), Short (okx) Спред на цену: 2.123% | Фандинг: -0.022% | Спред общий: 2.101% ❌ не арбитражить (ликв. Long: ask1: 1.23 bid1: 1.22 spread 48.4 bps > 30.0)
💰 SOL Long (mexc), Short (bitget) Спред на цену: 2.568% | Фандинг: 0.001% | Спред общий: 2.569% ✅ арбитражить (mexc: 15.234 SOL, bitget: 15.198 SOL)
💰 ALL Long (gate), Short (binance) Спред на цену: 10.121% | Фандинг: -0.022% | Спред общий: 10.099% ❌ не арбитражить (ликв. Short: sell impact 65.2 bps > 50.0; делистинг)
```

**Примечание:** 
- Префикс `💰` (эмодзи) используется для визуального выделения найденных арбитражных возможностей в логах
- Все числа отображаются с точностью до **3 знаков после запятой**
- **Спред на цену** - спред открытия позиции (price spread)
- **Фандинг** - спред на фандинги (funding spread), сокращение от "funding"
- **Спред общий** - сумма спреда на цену и спреда на фандинги (total spread = price spread + funding spread)
- После каждого спреда выводится **вердикт**: `✅ арбитражить` или `❌ не арбитражить`
- Если вердикт `✅ арбитражить`, в скобках выводятся **количества монет**, которые можно купить на каждой бирже за `SCAN_COIN_INVEST` (например, `(gate: 1.234 BTC, bingx: 1.230 BTC)`)
- Если вердикт `❌ не арбитражить`, в скобках выводятся **причины** отказа
- Вердикт выставляется автоматически на основе проверки ликвидности и новостей (делистинг + безопасность)
- Для вердикта "✅ арбитражить" автоматически отправляется сообщение в Telegram (если включено)

**Логика вердикта:**
- **✅ арбитражить**: ликвидность OK на обеих биржах (spread ≤ 30 bps, impact ≤ 50 bps) И нет проблемных новостей (делистинг/безопасность)
- **❌ не арбитражить**: ликвидность недостаточна на одной из бирж ИЛИ найдены новости о делистинге ИЛИ найдены новости о безопасности/взломах

**Причины отказа (выводятся в скобках после вердикта "❌ не арбитражить"):**
- **Ликвидность Long биржи:** `ликв. Long: {причина}` - например, `ask1: 1.23 bid1: 1.22 spread 48.4 bps > 30.0` или `buy impact 65.2 bps > 50.0` или `not enough depth for 50 USDT (buy_filled=35.2)`
- **Ликвидность Short биржи:** `ликв. Short: {причина}` - например, `sell impact 65.2 bps > 50.0` или `spread 55.4 bps > 30.0`
- **Делистинг:** `делистинг` - найдены новости о делистинге монеты на одной из бирж
- **Безопасность:** `безопасность` - найдены новости о безопасности/взломах, связанные с монетой
- **Несколько причин:** объединяются через `; `, например: `(ликв. Long: spread 45.2 bps > 30.0; ликв. Short: sell impact 65.1 bps > 50.0)`

## Telegram интеграция

### Настройка
В файле `.env` необходимо указать:
```env
# Режим работы (test или prod)
ENV=test

# Telegram настройки
BOT_TOKEN=your_bot_token_here
TEST_CHANNEL_ID=@ArbTest
FREE_CHANNEL_ID=@YourProdChannel

# Включить/выключить Telegram
ENABLE_TELEGRAM=true

# Минимальный спред для отправки в Telegram (в процентах)
TELEGRAM_MIN_SPREAD=2.0

# Интервал повторных отправок одинакового спреда
TELEGRAM_REPEAT_INTERVAL=3
```

### Режимы работы и каналы
- **`scan_spreads.py`** всегда отправляет сообщения в `TEST_CHANNEL_ID` (независимо от `ENV`)
- **`bot.py`** всегда отправляет сообщения в `FREE_CHANNEL_ID` (независимо от `ENV`)
- Оба бота могут работать одновременно в режиме `ENV=test`

### Автоматическая отправка сообщений
Сканер `scan_spreads.py` автоматически отправляет сообщения в Telegram при обнаружении арбитражных возможностей с вердиктом "✅ арбитражить".

**Условия отправки:**
- Спред >= `MIN_SPREAD` (из .env)
- Вердикт анализа: "✅ арбитражить" (ликвидность OK на обеих биржах И нет проблемных новостей)
- Telegram включен (`ENABLE_TELEGRAM=true`)
- Канал настроен (`TEST_CHANNEL_ID` для `scan_spreads.py`, `FREE_CHANNEL_ID` для `bot.py`)

**Формат сообщения:**

**Вариант 1: Изображение таблицы (приоритет, если установлен Pillow)**
- Автоматически генерируется изображение таблицы с данными арбитража
- Таблица содержит колонки: `coin`, `fr_long`, `fr_short`, `pr_spread`, `fr_spread`, `total_spread`, `ex_spread`
- Все числовые значения округляются до 3 знаков после запятой
- Подпись к изображению:
  ```
  🔔 Signal: JELLYJELLY (for liq: 40.0 USDT)
  JELLYJELLY Long (Xt), Short (Okx) max total spread: 3.856
  ```
- Где `max total spread` - максимальный общий спред из всех возможностей для монеты
- Пара бирж (Long/Short) берется из возможности с максимальным total_spread

**Вариант 2: Текстовое сообщение (fallback)**
```
🔔 Signal: FLOW (Liq: 50.0 USDT)

━━━━━━━━━━━━━━━━━━

🟢 LONG (Bybit)
├ Price: 0.0973
└ Funding: 0.001250%

🔴 SHORT (Gate)
├ Price: 0.0999
└ Funding: -0.109700%

━━━━━━━━━━━━━━━━━━

📊 Spreads:
• Price Spread: 2.612%
• Funding Spread: -0.111%

💎 Strategy: FLOW Long (Bybit) / Short (Gate)
```

**Особенности формата:**
- **Изображение таблицы (приоритет):** Если установлен Pillow, автоматически генерируется и отправляется изображение таблицы. Если генерация не удалась или Pillow не установлен, отправляется текстовое сообщение (fallback)
- HTML-разметка для форматирования текстовых сообщений (жирный текст, моноширинный шрифт для цен/фандингов)
- Разделители из символов ━ для визуального разделения секций (только в текстовых сообщениях)
- Древовидная структура (├ └) для отображения данных LONG/SHORT (только в текстовых сообщениях)
- Цветовые индикаторы: 🟢 для LONG, 🔴 для SHORT
- Количество инвестиций отображается в заголовке
- Названия бирж автоматически капитализируются (bybit → Bybit)
- Ссылки на торговые страницы формируются автоматически; для Bybit trade-ссылка используется без ru-префикса: `https://www.bybit.com/trade/usdt/{SYMBOL}`
- Все числовые значения в таблице округляются до 3 знаков после запятой

**Важно:**
- Все данные для сообщения берутся из сканера, без дополнительных API-запросов
- Фандинг запрашивается в сканере отдельно от тикера, поэтому обычно доступен в сообщении
- Если фандинг отсутствует (timeout или ошибка), показывается "N/A" или "none"
- Цена вычисляется как среднее от bid/ask, если price отсутствует
- Информация о ликвидности и новостях не показывается в сообщении (используется только для внутренней проверки)
- Для генерации изображений требуется библиотека Pillow (`pip install Pillow`)

## Последние изменения

### Канонизация монет FUN vs SPORTFUN (важно для корректных спредов)
У некоторых бирж под похожими тикерами скрываются **разные контракты**:
- **FUN** — это `FUN` / `FUNTOKEN` (цена порядка ~0.002)
- **SPORTFUN** — это `SPORTFUN` (Sport.Fun) (цена порядка ~0.10)

Если смешивать их в одном расчёте — появляются “космические” спреды в тысячи процентов.

**Решение (канонизация):**
- В коде теперь используются **два канонических тикера**: `FUN` и `SPORTFUN`.
- Для каждой биржи реализовано сопоставление:
  - **input (FUN/SPORTFUN)** → **правильный symbol** для API (`_normalize_symbol()`)
  - **coin list биржи** → **канонический тикер** (`coin_list_fetchers.py`), чтобы `scan_spreads.py`/`one_coin_bot.py` не строили пары “FUN vs SPORTFUN”.

**Маппинг по биржам (как в UI):**
- **Gate**: `FUN_USDT` = **SPORTFUN** (а **FUN** там нет)
- **XT**: `fun_usdt` = **FUN** (SPORTFUN нет)
- **Binance**: `FUNUSDT` = **FUN**, `SPORTFUNUSDT` = **SPORTFUN**
- **MEXC**: `FUN_USDT` = **FUN**, `SPORTFUN_USDT` = **SPORTFUN**
- **BingX**: `FUNTOKEN-USDT` = **FUN**, `SPORTFUN-USDT` = **SPORTFUN**
- **Bitget**: `FUNTOKENUSDT` = **FUN**, `FUNUSDT` = **SPORTFUN**

### Исправление расчета цен для количества монет
- **Проблема:** Количество монет рассчитывалось с fallback на `price`, что могло привести к несоответствию со спредом (спред считался по `ask`/`bid`, а количество монет — по `price`)
- **Решение:** Упрощена логика извлечения цен в `scan_spreads.py`:
  - Для Long: используется **только** `ask` (цена покупки) — та же, что используется для расчета спреда
  - Для Short: используется **только** `bid` (цена продажи) — та же, что используется для расчета спреда
  - Убран fallback на `price` и среднее от `bid/ask`
  - Удален sanity-check на `ratio > 10x` (чтобы не скрывать реальные ситуации)
- **Результат:** Количество монет теперь всегда соответствует реальному спреду, так как используются те же цены (`ask_long` и `bid_short`)

### Исправление получения funding rate для Bybit
- **Проблема:** Bybit возвращал предыдущую примененную ставку фандинга (из `/v5/market/funding/history`), которая не соответствовала текущей ставке в UI
- **Решение:** Изменена логика получения funding rate для Bybit:
  - Приоритетно используется `fundingRate` из `/v5/market/tickers` (текущая/следующая ставка, как в UI)
  - Fallback на `/v5/market/funding/history` (предыдущая примененная ставка), если tickers не вернул fundingRate
- **Результат:** Теперь бот получает актуальную ставку фандинга, соответствующую UI биржи

### Добавлена поддержка отправки изображений в Telegram
- **Новая функциональность:** `scan_spreads.py` теперь может отправлять изображения таблиц с данными арбитража вместо текстовых сообщений
- **Реализация:**
  - Добавлен метод `send_photo()` в `telegram_sender.py` для отправки изображений через Telegram Bot API
  - Создана функция `_generate_arbitrage_table_image()` в `scan_spreads.py` для генерации изображений таблиц
  - Используется библиотека Pillow для создания изображений
- **Формат таблицы:**
  - Колонки: `coin`, `pr_long`, `pr_short`, `fr_long`, `fr_short`, `pr_spread`, `fr_spread`, `total_spread`, `ex_spread`
  - Все числовые значения округляются до 3 знаков после запятой
  - Колонки `Long` и `Short` удалены (информация о биржах сохраняется в `ex_spread`)
- **Подпись к изображению:**
  - Формат: `🔔 Signal: {coin} (for liq: {SCAN_COIN_INVEST:.1f} USDT)\n{coin} Long ({long_ex}), Short ({short_ex}) max total spread: {max_spread:.3f}`
  - Где `max total spread` - максимальный общий спред из всех возможностей для монеты
  - Пара бирж берется из возможности с максимальным total_spread
- **Логика отправки:**
  - Если Pillow установлен и генерация изображения успешна → отправляется изображение
  - Если генерация не удалась или Pillow не установлен → отправляется текстовое сообщение (fallback)
- **Требования:** Для работы требуется установить Pillow: `pip install Pillow`

### Оптимизация кеша новостей и запросов к X API (Twitter)
- **Кеш новостей в сканерах (`scan_spreads.py`, `one_coin_bot.py`):**
  - Ключ кеша: **`(coin, exchange)`** (вместо `(coin, long_ex, short_ex)`).
  - Это позволяет не делать повторные запросы при новых комбинациях бирж:
    - есть кеш `BTC-bybit` и `BTC-binance` → для `BTC-bybit+gate` запрашиваем только `BTC-gate`.
- **X API (`x_news_monitor.py`):**
  - Внутренний кеш: ключ **`(query, start_bucket)`**, где `start_bucket` — 5‑минутное “ведро” времени.
    - Раньше кеш включал точный `start_time` (ISO), который меняется каждую секунду → кеш почти не попадал.
  - Если API возвращает **429**, монитор запоминает время сброса лимита и **пропускает запросы до reset**.
  - В `scan_spreads.py`/`one_coin_bot.py` X дергается **только если** по официальным announcements не найдено:
    - делистинга (для delisting),
    - security‑событий (для security).

### Примечание про MEXC FUN/SPORTFUN
На MEXC **оба** контракта существуют одновременно, поэтому:
- `FUN` всегда маппится в `FUN_USDT`
- `SPORTFUN` всегда маппится в `SPORTFUN_USDT`
И в `coin_list_fetchers.py` эти два контракта **не переименовываются через `displayName`**, чтобы не смешивать монеты.

### Исправления в coin_list_fetchers.py

**Bybit:**
- Добавлен фильтр `contractType == "LinearPerpetual"` для исключения фьючерсов с датой экспирации
- Теперь получаются только бессрочные контракты (PERP)

**MEXC:**
- Исправлен блок проверки `state`: заменен `pass` на `continue` для неактивных контрактов
- Фильтруются только явно неактивные состояния (state в "3", "4", "5")

**Bitget:**
- Исправлен `PRODUCT_TYPE` с `"usdt-futures"` на `"umcbl"` (USDT-M Futures)
- Убран лишний `.upper()` при добавлении монет в список
- Используется endpoint `/api/v2/mix/market/tickers` вместо `/api/v2/mix/market/contracts`

**OKX:**
- Добавлен фильтр по `state == "live"` для получения только активных инструментов

**Gate.io:**
- Улучшена обработка различных форматов ответа API
- Добавлена поддержка полей `name` и `contract` для названия контракта
- Улучшена фильтрация по статусу торговли

**XT.com:**
- Изменен endpoint на `/future/market/v1/public/cg/contracts`
- Улучшена обработка различных форматов ответа API (список или dict-обертка)

### Автоматическое открытие позиций (position_opener.py)

**Описание:**
Модуль `position_opener.py` реализует автоматическое открытие Long и Short позиций на биржах через API ключи из `.env`.

**Основные требования:**
- Ордера: **лимитные** по лучшим ценам стакана (ask для Long, bid для Short)
- Режим исполнения: **строго полное исполнение** (100% или отмена)
- Тип ордера: **FOK (Fill-Or-Kill)** для обеих бирж (Bybit и Gate)
- Глубина стакана: **максимум 3 уровня**
- Логика уровней: попытка на **лучшем уровне** → если не исполнилось, пробуем **2-й уровень** → затем **3-й уровень** (и всё)

**Поддерживаемые биржи:**
- **Bybit** (USDT-M Perp, v5): `/v5/order/create` с `timeInForce="FOK"`
- **Gate.io** (USDT-M Perp, v4): `/api/v4/futures/usdt/orders` с `tif="fok"`

**Переменные окружения:**
- `BYBIT_API_KEY`, `BYBIT_API_SECRET`
- `GATEIO_API_KEY`, `GATEIO_API_SECRET`

**Процесс открытия позиций:**

1. **Preflight проверки** (параллельно на обеих биржах):
   - Получение стакана (orderbook) для определения best ask/bid
   - Проверка минимальных ограничений (min order size, min notional)
   - Проверка шагов цены/количества (tick size, lot size)
   - Если на одной бирже проблема — ордера не выставляются

2. **Планирование ордеров:**
   - Выбор цены из стакана: берём первые 3 уровня, выбираем уровень, где cumulative size >= требуемого количества
   - Округление цены по tick size (для Long — вверх, для Short — вниз)
   - Округление количества по lot size

3. **Выставление ордеров** (параллельно):
   - Bybit Long: лимит buy по выбранной цене, qty=количество монет, timeInForce=FOK
   - Gate Short: лимит sell по выбранной цене, size=контракты, tif=fok

4. **Проверка fill** (после ~1-2 секунд):
   - Bybit: запрос `/v5/order/realtime` → если не найден, fallback на `/v5/order/history`
   - Gate: запрос `/api/v4/futures/usdt/orders/{order_id}`
   - Проверка, что `filled >= coin_amount` на обеих ногах

5. **Логика уровней (1→2→3):**
   - Если на лучшей цене ордер не исполнился полностью (FOK отменился) → пробуем 2-й уровень
   - Если на 2-м уровне не исполнилось → пробуем 3-й уровень
   - Если на 3-м уровне не исполнилось → операция считается неуспешной

**Результат:**
- Если обе ноги исполнились полностью → запускается мониторинг спредов
- Если хотя бы одна нога не исполнилась → мониторинг не запускается, выводится лог "Мониторинг не запущен"

**Логирование:**
- Все числовые значения в логах форматируются до 3 знаков после запятой с удалением нулей на конце
- Выводится информация о планах ордеров, попытках исполнения, статусах и результатах

**Интеграция с bot.py:**
- Вызывается при ответе "Да" на вопрос "Открыть позиции в лонг и шорт?"
- После успешного открытия обеих позиций автоматически запускается мониторинг спредов

# МОИ заметки по FUN
По монете FUN есть две похожиее монеты, сматч их, чтобы выводились правильные цены
на gate - это https://www.gate.com/ru/futures/USDT/FUN_USDT SPORTFUN
на xt - это https://www.xt.com/ru/futures/trade/fun_usdt FUN
на binance - есть https://www.binance.com/ru/futures/FUNUSDT FUN и https://www.binance.com/ru/futures/SPORTFUNUSDT SPORTFUN
на bybit - монеты нет
на mexc - есть https://www.mexc.com/ru-RU/futures/SPORTFUN_USDT SPORTFUN и https://www.mexc.com/ru-RU/futures/FUN_USDT FUN
на bingx - есть https://bingx.com/ru-ru/perpetual/SPORTFUN-USDT SPORTFUN  и https://bingx.com/ru-ru/perpetual/FUNTOKEN-USDT FUN
на okx - монеты нет
на bitget - есть https://www.bitget.com/ru/futures/usdt/FUNUSDT SPORTFUN и https://www.bitget.com/ru/futures/usdt/FUNTOKENUSDT FUN 