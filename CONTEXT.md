# Контекст проекта ArbitragePerp

## Описание проекта
Бот для анализа арбитража криптовалюты на фьючерсах между биржами (Bybit и Gate.io).

## История создания
Проект создан на основе логики из проекта `arbitrage`, но адаптирован для работы с фьючерсами и фандингами.

## Архитектура

### Основные компоненты:
1. **exchanges/** - Модуль для работы с биржами
   - `async_base_exchange.py` - Базовый класс для всех бирж
   - `async_bybit.py` - Клиент Bybit для фьючерсов
   - `async_gate.py` - Клиент Gate.io для фьючерсов
   - `async_mexc.py` - Клиент MEXC для фьючерсов
   - `async_lbank.py` - Клиент LBank для фьючерсов
   - `async_xt.py` - Клиент XT.com для фьючерсов
   - `async_binance.py` - Клиент Binance для фьючерсов

2. **bot.py** - Основной бот, который:
   - Парсит вводные данные в формате: "монета Long (биржа), Short (биржа)"
   - Получает данные о ценах фьючерсов и фандингах с обеих бирж
   - Вычисляет спреды
   - Выводит информацию в лог

3. **input_parser.py** - Парсер вводных данных

4. **config.py** - Конфигурация (логирование)

## Формат ввода
```
монета Long (биржа), Short (биржа)
```
Пример: `CVC Long (bybit), Short (gate)`

## Формат вывода
Бот выводит:
- Цена монеты на фьючерс (монета) биржа: __
- Фандинг (монета) биржа: __
- Спред на цену на фьючерс (биржа1 и биржа2): __
- Спред на фандинги (биржа1 и биржа2): __

## API эндпоинты

**Важно:** Все используемые эндпоинты - публичные (market data), API ключи не требуются!

### Bybit:
- **Базовый URL:** `https://api.bybit.com`
- **Тикер фьючерса:** `/v5/market/tickers` - публичный API
- **Фандинг:** `/v5/market/funding/history` - публичный API
- **Обязательные параметры:**
  - Тикер: `category=linear`, `symbol=COINUSDT`
  - Фандинг: `category=linear`, `symbol=COINUSDT`, `limit=1`
- **Формат символов:** `COINUSDT` (без подчеркивания, например, `CVCUSDT`, `BTCUSDT`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Возвращает данные в формате `{"retCode": 0, "result": {...}}`
  - Если `retCode != 0`, монета недоступна или произошла ошибка
  - Тикер возвращает `lastPrice`, `bid1Price`, `ask1Price`
  - Фандинг возвращает историю, берется последний элемент (`fundingRate`)
- **Валидация цен (sanity-check):**
  - Bybit иногда возвращает `"0"` или пустые значения для `bid1Price`/`ask1Price` на неликвидных инструментах
  - Реализована функция `_safe_px()` для безопасного преобразования цен с проверками:
    - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
    - Проверка, что цена > 0
    - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
    - Порог 10x обычно достаточен; для очень волатильных инструментов можно сделать параметром (5x-20x)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask

### Gate.io:
- **Базовый URL:** `https://api.gateio.ws`
- **Тикер фьючерса:** `/api/v4/futures/usdt/tickers` - публичный API
- **Фандинг:** `/api/v4/futures/usdt/funding_rate` - публичный API
- **Orderbook:** `/api/v4/futures/usdt/order_book` - публичный API
- **Обязательные параметры:**
  - Тикер: `contract=COIN_USDT`
  - Фандинг: `contract=COIN_USDT`, `limit=1`
  - Orderbook: `contract=COIN_USDT`, `limit` (от 1 до 200)
- **Формат символов:** `COIN_USDT` (с подчеркиванием, например, `CVC_USDT`, `BTC_USDT`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Может возвращать данные как список или словарь
  - Тикер возвращает `last`, `bid`, `ask` (или `highest_bid`/`lowest_ask`)
  - Фандинг возвращает массив `[{"t": timestamp, "r": "0.000157"}]`, берется первый элемент с полем `r`
  - Если данные не получены, монета недоступна или произошла ошибка
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 20 раз (в любую сторону), используется `lastPrice` как fallback (порог 20x для микро-альтов)
  - Для микро-альтов с ценой < 0.0001 sanity-check отключается (могут быть реальные скачки)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Поддержка альтернативных названий полей: `bid`/`highest_bid`, `ask`/`lowest_ask`
  - Проверка правильного контракта в списке: если API возвращает список, ищется точный контракт по полю `contract`
  - Используется в `get_futures_ticker()` для bid/ask
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Парсинг orderbook (поддержка разных форматов):**
  - Реализован метод `_parse_ob_levels()` для нормализации форматов orderbook
  - Gate.io может возвращать уровни в разных форматах:
    1. **REST/WS-legacy формат:** `[{"p":"97.1","s":2245}, ...]` (словари с ключами `p`/`price` и `s`/`size`)
    2. **REST формат:** `[["97.1","2245"], ...]` или `[[price, size], ...]` (списки/кортежи)
  - Метод нормализует оба формата к единому виду: `[[price(float), size(float)], ...]`
  - Обработка ошибок: проверка типов, конвертация в float, валидация значений
  - Нормализация размера: если `size < 0`, применяется `abs(size)` (на всякий случай)
  - Защита от безумных ответов: ограничение на 5000 уровней
  - Это предотвращает ошибки "неверный формат bids" и корректно обрабатывает оба формата ответов Gate.io

### MEXC:
- **Базовый URL:** `https://contract.mexc.com` (отдельный домен для фьючерсов)
- **Fallback URL:** `https://futures.mexc.com` (часто более стабильный домен для futures)
- **Тикер фьючерса:** `/api/v1/contract/ticker` - публичный API
- **Фандинг:** `/api/v1/contract/funding_rate/{symbol}` - публичный API (символ в path)
- **Orderbook:** `/api/v1/contract/depth/{symbol}` - публичный API (символ в path)
- **Обязательные параметры:**
  - Тикер: `symbol=COIN_USDT` (query параметр, с fallback на `COINUSDT` без подчеркивания)
  - Фандинг: `{symbol}` в path (например, `/api/v1/contract/funding_rate/DN_USDT`), с fallback на `COINUSDT` без подчеркивания
  - Orderbook: `{symbol}` в path (например, `/api/v1/contract/depth/DN_USDT`), `limit` в query (от 1 до 200), с fallback на `COINUSDT` без подчеркивания
- **ВАЖНО:** По Contract V1 API, `funding_rate` и `depth` используют символ в path-параметре, а не в query параметрах. Это критично для корректной работы API.
- **Формат символов:** `COIN_USDT` (с подчеркиванием, например, `CVC_USDT`, `BTC_USDT`)
  - Если запрос с `_USDT` не дал данных, вернул ошибку (`code != 0`), или вернул dict без полезных полей (`data`, `result`, `code`), автоматически пробуется формат без подчеркивания (`COINUSDT`)
  - Fallback применяется во всех методах (ticker, funding, orderbook) для совместимости с разными версиями API
  - Проверка `code` выполняется только если поле присутствует в ответе (защита от нестандартных форматов)
  - **`looks_empty` проверка:** Сужена до проверки только верхнего уровня (`data`, `result`, `code`), так как для MEXC поля `bids`/`asks`/`lastPrice`/`last` обычно находятся внутри `data`, а не на верхнем уровне. Это предотвращает ложные fallback при валидных ответах вида `{"code":0,"data":...}`
  - В `get_funding_rate()` `symbol_to_find` строится от фактически используемого `symbol` (после fallback, если он был применен)
  - **Поддержка полей `data` и `result`:** Во всех методах (ticker, funding, orderbook) сначала пробуется `data.get("data")`, если `None` — используется `data.get("result")`, если и оно `None` — используется весь `data` (fallback для совместимости с разными форматами ответов API)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Может возвращать данные как список или словарь в поле `data`
  - Проверяется, что `code == 0` для успешного ответа
  - Тикер возвращает `lastPrice`, `bid1`, `ask1`
  - Фандинг возвращает `fundingRate` (уже в десятичном формате, например, 0.000052 = 0.0052%)
  - Если данные не получены или символ не совпадает, монета недоступна или произошла ошибка
- **Канонизация символов:**
  - Реализована функция `_canon()` для нормализации символов при сравнении
  - Убирает дефисы и подчеркивания: `GPSUSDT`, `GPS-USDT`, `GPS_USDT` → `GPSUSDT`
  - Используется в `get_funding_rate()` для надежного поиска символа в списке
  - Это позволяет находить символы независимо от формата, в котором их возвращает API
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
  - Порог 10x обычно достаточен; для очень волатильных инструментов можно сделать параметром (5x-20x)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Используется в `get_futures_ticker()` для bid/ask
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Безопасный поиск фандинга:**
  - Убран опасный fallback `item[0]` при поиске фандинга в списке
  - Если символ не найден в списке, возвращается `None` вместо использования фандинга другой монеты
  - Используется канонизация символов для надежного сравнения
  - `symbol_to_find` строится от фактически используемого `symbol` (после fallback, если он был применен)
  - Улучшенное логирование: в warning указывается `coin`, `tried` (фактический символ) и `want` (канонизированный символ для поиска)
  - Поддержка полей `data` и `result`: сначала пробуется `data.get("data")`, если `None` — используется `data.get("result")`
  - Проверка перед парсингом: если `data.get("data")` и `data.get("result")` оба `None`, логируется предупреждение о неожиданном формате
  - **Валидация symbol после fallback:** После получения `item` проверяется, что `item.get("symbol")` (с канонизацией) совпадает с запрошенным `symbol_to_find`. Это особенно важно после fallback, чтобы убедиться, что получен фандинг для правильной монеты
  - **Улучшенное логирование валидации:** В warning показываются и raw, и canon версии символов для лучшей диагностики: `получен фандинг для {item_symbol} (canon={got_symbol}) вместо {symbol} (want raw) / {symbol_to_find} (want canon)`
  - Это предотвращает получение фандинга от неправильной монеты и ускоряет диагностику проблем
- **Парсинг orderbook (поддержка разных форматов и доменов):**
  - Реализован метод `_parse_ob_levels()` для нормализации форматов orderbook
  - MEXC может возвращать уровни в разных форматах:
    1. **Списки:** `[["price","size"], ...]` или `[[price, size], ...]` (обычный формат)
    2. **Словари:** `[{"price":"...","quantity":"..."}, ...]` (реже, но встречается)
  - Метод нормализует оба формата к единому виду: `[[price(float), size(float)], ...]`
  - Обработка ошибок: проверка типов, конвертация в float, валидация значений
  - Нормализация размера: если `size < 0`, применяется `abs(size)` (на всякий случай)
  - **Fallback на альтернативный домен:** Реализован метод `_request_json_with_domain_fallback()` для автоматического переключения между доменами при ошибках соединения
  - При ошибке соединения на основном домене (`contract.mexc.com`) автоматически пробуется fallback домен (`futures.mexc.com`)
  - Короткий backoff (0.25 секунды) между попытками для снижения нагрузки
  - Ограничение `limit`: автоматически ограничивается в диапазоне 1-200 (`limit_i = max(1, min(int(limit), 200))`)
  - Это предотвращает ошибки соединения и корректно обрабатывает оба формата ответов MEXC

### LBank:
- **Базовый URL:** `https://lbkperp.lbank.com` (отдельный домен для фьючерсов)
- **Тикер фьючерса:** `/cfd/openApi/v1/pub/marketData` - публичный API
- **Фандинг:** `/cfd/openApi/v1/pub/marketData` - публичный API
- **Orderbook:** `/cfd/openApi/v1/pub/depth` - публичный API
- **Обязательный параметр:** `productGroup=SwapU` (должен передаваться во всех запросах)
- **Формат символов:** `COINUSDT` (без подчеркивания, например, `IOTAUSDT`, `BTCUSDT`)
- **Примечание:** 
  - LBank использует публичный API, **API ключи не требуются**
  - API может возвращать пустые массивы данных для некоторых монет
  - Если монета недоступна, API вернет `data: []`
  - Для надежности сначала запрашивается список всех доступных инструментов через `/cfd/openApi/v1/pub/instrument`
  - Если данные не получены, монета помечается как недоступная/делистированная
- **Fallback для orderbook:**
  - Эндпоинт `/cfd/openApi/v1/pub/depth` может быть капризнее, чем `marketData`, и требовать другой формат символа
  - При получении orderbook пробуются несколько вариантов символа:
    1. `symbol_main` - символ, полученный через `resolve_symbol()` (из кеша инструментов)
    2. `symbol_norm` - нормализованный символ через `_normalize_symbol()` (например, `BTCUSDT`)
    3. `symbol_norm.lower()` - нижний регистр (например, `btcusdt`)
  - Если один из вариантов успешно возвращает данные, используется он
  - Если все варианты не сработали, выводится warning с перечислением всех попыток
- **Обработка HTTP 404:**
  - HTTP 404 для LBank означает, что публичный endpoint недоступен или неверные параметры
  - Теперь 404 логируется как warning с деталями URL и параметров для диагностики
  - Это помогает понять, является ли проблема в неверном формате символа или временной недоступности API
- **Кеширование инструментов:**
  - Список инструментов кешируется в памяти на 5 минут (TTL 300 секунд)
  - Это снижает количество запросов к API и риск rate-limit
  - Кеш обновляется автоматически при истечении TTL
- **Канонизация символов:**
  - Реализована функция `_canon()` для нормализации символов при сравнении
  - Убирает дефисы и подчеркивания: `GPSUSDT`, `GPS-USDT`, `GPS_USDT` → `GPSUSDT`
  - Используется в `_pick_market_item()` и `resolve_symbol()` для надежного поиска
  - Это позволяет находить символы независимо от формата, в котором их возвращает API
- **Проверка ошибок API:**
  - Реализована функция `_check_api_error()` для проверки ошибок в ответах API
  - Проверяет `success == False` и `str(error_code) != "0"` (корректно обрабатывает строковые значения типа `"0000"`)
  - Используется во всех методах (ticker, funding, orderbook) перед парсингом данных
  - Это предотвращает парсинг мусора/пустоты при ошибках API и корректно обрабатывает случаи, когда API возвращает ошибку вместо данных
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
  - Порог 10x обычно достаточен; для очень волатильных инструментов можно сделать параметром (5x-20x)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Используется в `_parse_ticker_response()` для bid/ask и может быть переиспользован в других местах
  - Это предотвращает использование мусорных значений типа `"2240434730514.30"`, `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Валидация orderbook:**
  - Проверка формата уровней: убеждается, что `bids[0]` и `asks[0]` - это список/кортеж длины >= 2
  - Проверка конвертации в float: убеждается, что элементы `bids[0][0]`, `bids[0][1]`, `asks[0][0]`, `asks[0][1]` можно конвертировать в `float`
  - Защита от строк, объектов или невалидных типов данных
  - Это предотвращает падения в `check_liquidity` при неверном формате данных
- **Упрощенная логика поиска:**
  - Везде используется единая функция `_pick_market_item()` для поиска нужного символа
  - Убраны special-case для dict payload, что делает код проще и надежнее
  - Функция проверяет поля `data` и `result` в ответе API
  - Консистентное использование `(list, tuple)` для проверки типов в depth парсере и orderbook

### XT.com:
- **Базовый URL:** `https://fapi.xt.com` (отдельный домен для фьючерсов)
- **Тикер фьючерса:** `/future/market/v1/public/q/ticker` - публичный API
- **Фандинг:** `/future/market/v1/public/q/funding-rate` - публичный API
- **Обязательные параметры:**
  - Тикер: `symbol=coin_usdt`
  - Фандинг: `symbol=coin_usdt`
- **Формат символов:** `coin_usdt` (нижний регистр, с подчеркиванием, например, `cvc_usdt`, `gps_usdt`, `btc_usdt`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Возвращает данные в формате `{"returnCode": 0, "msgInfo": "success", "result": {...}}`
  - Если `returnCode != 0`, монета недоступна или произошла ошибка
  - Тикер возвращает `c` (last price), `b` (bid), `a` (ask) в поле `result`
  - Фандинг возвращает `fundingRate` в поле `result` (в десятичном формате, например, -0.02 = -2.0%)
  - **КРИТИЧНО:** Символы чувствительны к регистру - обязательно использовать нижний регистр
  - Если данные не получены, монета недоступна или произошла ошибка
- **Валидация цен (sanity-check):**
  - XT.com иногда возвращает аномально большие значения для `bid`/`ask` (например, `184010056.0` вместо `0.00797`)
  - Реализована проверка на разумность значений:
    - Если `bid` или `ask` присутствуют и > 0, проверяется отклонение от `lastPrice`
    - Если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
    - Если `bid` или `ask` отсутствуют или равны 0, используется `lastPrice`
  - Это предотвращает использование некорректных данных, которые могут привести к космическим значениям спредов

### Binance:
- **Базовый URL:** `https://fapi.binance.com` (отдельный домен для USDT-M фьючерсов)
- **Тикер фьючерса:** `/fapi/v1/ticker/24hr` - публичный API
- **Фандинг:** `/fapi/v1/premiumIndex` - публичный API
- **Orderbook:** `/fapi/v1/depth` - публичный API
- **Обязательные параметры:**
  - Тикер: `symbol=COINUSDT`
  - Фандинг: `symbol=COINUSDT`
  - Orderbook: `symbol=COINUSDT`, `limit` (от 5 до 5000)
- **Формат символов:** `COINUSDT` (без подчеркивания, например, `CVCUSDT`, `BTCUSDT`)
- **Примечание:**
  - API полностью публичный, **API ключи не требуются**
  - Возвращает данные напрямую (без обертки в `result`)
  - Тикер возвращает `lastPrice`, `bidPrice`, `askPrice`
  - Фандинг возвращает `lastFundingRate` (в десятичном формате, например, 0.0001 = 0.01%)
  - Orderbook возвращает `bids` и `asks` как списки `[[price, size], ...]` (обычно строки)
  - Binance возвращает ошибки в формате `{"code": -1121, "msg": "Invalid symbol."}`
  - Успешные ответы не содержат поле `code`, ошибки содержат отрицательные коды
  - Если данные не получены или символ не найден, монета недоступна или произошла ошибка
- **Проверка ошибок API:**
  - Реализован метод класса `_is_api_error()` для проверки наличия поля `code` в ответе
  - Если `code` присутствует, ответ считается ошибкой
  - Улучшенное логирование: в warning указывается `symbol`, `code` и `msg` для диагностики
- **Валидация цен (sanity-check):**
  - Реализован метод класса `_safe_px()` для безопасного преобразования цен с проверками
  - Обработка ошибок при преобразовании в `float` (try/except для `TypeError`, `ValueError`)
  - Проверка, что цена > 0
  - Sanity-check: если цена отличается от `lastPrice` более чем в 10 раз (в любую сторону), используется `lastPrice` как fallback
  - Порог 10x обычно достаточен; для очень волатильных инструментов можно сделать параметром (5x-20x)
  - Проверка `lastPrice`: если `lastPrice <= 0`, функция возвращает `None` (монета недоступна)
  - Дополнительная проверка: если после всех проверок `bid > ask` (аномалия), оба значения устанавливаются в `lastPrice`
  - Используется в `get_futures_ticker()` для bid/ask
  - Это предотвращает использование мусорных значений типа `"1e-12"`, `"999999999"`, пустых строк или некорректных пар bid/ask
- **Валидация orderbook:**
  - Проверка формата уровней: убеждается, что `bids[0]` и `asks[0]` - это список/кортеж длины >= 2
  - Проверка конвертации в float: убеждается, что элементы `bids[0][0]`, `bids[0][1]`, `asks[0][0]`, `asks[0][1]` можно конвертировать в `float`
  - Защита от строк, объектов или невалидных типов данных
  - Ограничение `limit`: Binance принимает `limit` от 5 до 5000, код автоматически ограничивает значение в этих пределах (`limit_i = max(5, min(int(limit), 5000))`)
  - Это предотвращает падения в `check_liquidity` при неверном формате данных
- **Улучшенное логирование:**
  - Во всех методах добавлено детальное логирование с указанием `symbol` для диагностики
  - Логируются пустые ответы, ошибки API, неожиданные форматы данных, отсутствие полей
  - Это ускоряет диагностику проблем при работе с API

## Следующие шаги (TODO)
Пользователь упомянул, что в следующем сообщении будут дополнительные вычисления, которые нужно реализовать.

## Зависимости
- httpx - для асинхронных HTTP запросов
- python-dotenv - для работы с .env файлами


## Логика работы бота

### Основная концепция
Бот определяет моменты времени для открытия и закрытия арбитражных позиций, используя два разных типа спредов:
- **Спред открытия позиции (max)** - для входа в арбитраж
- **Спред закрытия позиции (min)** - для выхода из арбитража

### Мониторинг спреда открытия позиции (max)

**Назначение:** Определить оптимальный момент для открытия Long и Short позиций на разных биржах.

**Что показывает:**
- Первое число - спред открытия между ask (биржа Long) и bid (биржа Short)
- Название монеты (для проверки)
- Ставка фандинга на бирже Long (long fr)
- Ставка фандинга на бирже Short (short fr)
- Разница между ставками фандинга (fr spread)

**Формула расчета спреда открытия (Откр (max)):**
```
Спред открытия = (bid_short - ask_long) / ask_long * 100
```
- **Положительное значение** = выгодный арбитраж (bid_short > ask_long)
- **Отрицательное значение** = невыгодно открывать
- Используется для определения момента входа в арбитраж

**Когда открывать:**
- Когда спред открытия достигает максимального значения (заданного порога, например 9.5%)
- Общий спред (спред на цену + спред на фандинг) должен быть положительным и достаточным для покрытия комиссий

**Пример:**
- На разнице в ценах: +1.77%
- На разнице в ставках фандинга: -0.75%
- Итого общий спред: ~1.02%

### Мониторинг спреда закрытия позиции (Закр (min))

**Назначение:** Определить оптимальный момент для закрытия Long и Short позиций (обратные сделки).

**Что показывает:**
- Спред закрытия между bid (биржа Long) и ask (биржа Short)
- Это обратные цены относительно открытия позиции
- Порог выхода (thr) - минимальный спред, при котором закрытие экономически оправдано

**Формула расчета спреда закрытия (Закр (min)):**
```
Спред закрытия = (bid_long - ask_short) / ask_short * 100
```
- **Положительное значение** = выгодно закрывать (bid_long > ask_short)
- **Отрицательное значение** = невыгодно закрывать (цены еще не сошлись)
- Используется для определения момента выхода из арбитража

**Порог выхода (thr):**
Порог выхода рассчитывается методом `get_exit_threshold_pct()` и учитывает:
- **Комиссия закрытия Long:** 0.04% (taker комиссия на бирже Long)
- **Комиссия закрытия Short:** 0.04% (taker комиссия на бирже Short)
- **Запас:** 0.10% (буфер для покрытия проскальзывания и других издержек)

**Формула порога выхода:**
```
Порог выхода = 0.04% + 0.04% + 0.10% = 0.18%
```

**Когда закрывать:**
- Когда спред закрытия (`Закр (min)`) достигает или превышает порог выхода (`thr = 0.18%`)
- Это означает, что закрытие покрывает все комиссии и запас, выход экономически оправдан
- **Условие:** `Закр (min) >= 0.18%` → можно закрывать позиции

### Ключевое различие между спредами

**Важно:** Спред открытия ≠ спред закрытия - это РАЗНЫЕ спреды!

**При открытии позиции:**
- Long: покупаем по **ask** на бирже A
- Short: продаем по **bid** на бирже B
- Спред = (bid_B - ask_A) / ask_A * 100
- Положительное значение = выгодно открывать (bid_B > ask_A)

**При закрытии позиции:**
- Long: продаем по **bid** на бирже A
- Short: покупаем по **ask** на бирже B
- Спред = (bid_A - ask_B) / ask_B * 100

Это важно, потому что при открытии и закрытии используются разные стороны стакана (ask/bid), поэтому спреды различаются.

### Расчет спредов

1. **Спред на цену (pr_spread):**
   
   **Общий спред на цену (для анализа арбитража):**
   - Формула: `(price_short - price_long) / price_long * 100`
   - Для схемы Long (A) / Short (B):
     - Положительный спред = хорошо (цена на Short бирже выше, можно продать дороже)
     - Отрицательный спред = плохо (цена на Short бирже ниже, продаем дешевле)
   - Используется для первоначального анализа арбитражной возможности
   
   **Спред для открытия позиции:**
   - Формула: `(ask_long - bid_short) / bid_short * 100`
   - Используется при мониторинге для определения момента входа
   
   **Спред для закрытия позиции:**
   - Формула: `(bid_long - ask_short) / ask_short * 100`
   - Используется при мониторинге для определения момента выхода

2. **Спред на фандинг (fr_spread / Net funding):**
   - Формула: `Net funding = funding_short - funding_long`
   - Экономическая логика funding:
     - Если funding > 0: Long платит, Short получает
     - Если funding < 0: Long получает, Short платит
   - PnL для позиций:
     - PnL Long = -funding_long
     - PnL Short = +funding_short
   - Net funding = PnL_long + PnL_short = funding_short - funding_long
   - Показывает чистый эффект по фандингу за один funding-период
   - Положительное значение = прибыль, отрицательное значение = убыток
   - **Пример:** Long: -2.0%, Short: -2.5% → Net funding = (-2.5%) - (-2.0%) = -0.5% (убыток)

3. **Общий спред (total_spread):**
   - pr_spread + fr_spread
   - Учитывает как разницу в ценах, так и разницу в фандингах

### Настройки бота

- **Алерт спред min (%)**: Порог для закрытия позиции (например, -1%)
  - Когда спред закрытия достигает этого значения, приходит оповещение
- **Алерт спред max (%)**: Порог для открытия позиции (например, 9.5%)
  - Когда спред открытия достигает этого значения, приходит оповещение

### Работа бота

1. Бот каждую секунду запрашивает данные с бирж (цены ask/bid и фандинги)
2. Рассчитывает спреды открытия и закрытия
3. Выводит информацию в соответствующих окнах мониторинга
4. При достижении заданных порогов отправляет оповещения

### Формат вывода в логах мониторинга

В методе `monitor_spreads()` бот выводит информацию в следующем формате:

```
Закр (min): -4.27% (0.18%) | Откр (max): 3.92% | long_fr: -0.25 | short_fr: 0.01 | fr_spread: 0.263
```

**Расшифровка:**
- **Закр (min):** Спред закрытия позиции, рассчитывается по формуле `(bid_long - ask_short) / ask_short * 100`
  - Положительное значение = выгодно закрывать
  - Отрицательное значение = невыгодно закрывать (цены еще не сошлись)
  - В скобках `(0.18%)` указан порог выхода (thr) - минимальный спред, при котором закрытие экономически оправдано
  - **Условие для закрытия:** `Закр (min) >= 0.18%` → можно закрывать позиции
- **Откр (max):** Спред открытия позиции, рассчитывается по формуле `(bid_short - ask_long) / ask_long * 100`
  - Положительное значение = выгодно открывать
  - Отрицательное значение = невыгодно открывать
- **long_fr:** Ставка фандинга на бирже Long (в процентах)
- **short_fr:** Ставка фандинга на бирже Short (в процентах)
- **fr_spread:** Чистый эффект по фандингу, рассчитывается по формуле `funding_short - funding_long` (в процентах)
  - Положительное значение = прибыль от фандинга
  - Отрицательное значение = убыток от фандинга

**Пример интерпретации:**
- `Закр (min): -4.27% (0.18%)` - при закрытии будет убыток 4.27% из-за разницы цен (цены еще не сошлись). Порог выхода 0.18% не достигнут, закрывать не стоит.
- `Закр (min): 0.25% (0.18%)` - при закрытии будет прибыль 0.25% из-за разницы цен. Порог выхода 0.18% достигнут, закрытие экономически оправдано.
- `Откр (max): 3.92%` - при открытии будет прибыль 3.92% из-за разницы цен
- `fr_spread: 0.263` - за один funding-период будет прибыль 0.263% от фандинга

**Логика порога выхода:**
- Порог выхода (0.18%) учитывает комиссии закрытия обеих позиций (0.04% + 0.04%) и запас (0.10%)
- Когда `Закр (min) >= 0.18%`, закрытие покрывает все издержки и имеет смысл
- Если `Закр (min) < 0.18%`, закрытие не покрывает комиссии и запас, выход не оправдан

### Пример работы

**Открытие позиции:**
- Найдена ситуация: GLM Long на MEXC, Short на Bybit
- Спред открытия достиг 9.5% → оповещение
- Открываем Long на MEXC (покупаем по ask) и Short на Bybit (продаем по bid) одновременно

**Закрытие позиции:**
- Мониторим спред закрытия
- Когда спред закрытия достигает -1% → оповещение
- Закрываем Long на MEXC (продаем по bid) и Short на Bybit (покупаем по ask) одновременно

## Проверка делистинга

### Назначение
Бот автоматически проверяет наличие новостей о делистинге монеты на биржах, участвующих в арбитраже. Это критически важно, так как торговля делистированной монетой невозможна.

### Когда выполняется проверка
Проверка делистинга выполняется автоматически после получения базовой информации о монете (цены и фандинги), но до начала мониторинга спредов.

### Поддерживаемые биржи
- **Bybit** - через официальный API announcements
- **Gate.io** - через HTML-скрапинг страниц объявлений
- **MEXC** - через HTML-скрапинг страниц объявлений
- **LBank** - поддержка может быть ограничена (зависит от доступности публичного API)

### Период поиска
По умолчанию проверяются объявления за последние **60 дней**. Это позволяет найти недавние делистинги, которые могли быть объявлены месяц назад.

### Как работает проверка

#### 1. Определение бирж для проверки
Бот проверяет делистинг только на тех биржах, которые участвуют в конкретном арбитраже.

**Пример:**
- Запрос: `"OBOL Long (bybit), Short (gate)"`
- Проверка делистинга выполняется только на **Bybit** и **Gate.io**

#### 2. Получение объявлений с бирж

**Bybit:**
- Используется официальный API: `GET /v5/announcements/index`
- Фильтры запроса:
  - `type=delistings` - только делистинги
  - `tag=Derivatives` - только деривативы (фьючерсы)
  - `locale=en-US`
  - `limit=50` на страницу
- Данные получаются с пагинацией (до 50 страниц)
- Используется UTC для корректного сравнения дат
- Буфер 6 часов для предотвращения потери событий на границе периода

**Gate.io и MEXC:**
- Используется HTML-скрапинг страниц объявлений
- Парсятся заголовки и тексты объявлений
- Извлекаются ссылки на полные объявления

#### 3. Поиск делистинга по монете

**Регулярное выражение для поиска монеты:**
- Ищет монету как отдельное слово: `OBOL`
- Ищет монету с суффиксом USDT: `OBOLUSDT`
- Учитывает, что фьючерсы торгуются только к USDT
- Пример регулярки: `(?<![A-Z0-9])OBOL(?:USDT)?(?![A-Z0-9])`

**Ключевые слова делистинга:**
- Английские: "delist", "delisting", "removal", "removed", "discontinued", "terminated", "trading suspended", "trading halt", "will be delisted", "to be delisted", "delisting announcement", "removal from trading", "cease trading"
- Русские: "удаление", "делистинг", "прекращение торговли", "удаление с биржи", "прекращение листинга", "исключение из торговли"

**Условия для определения делистинга:**
1. Монета упомянута в заголовке или тексте объявления (как `OBOL` или `OBOLUSDT`)
2. В тексте присутствуют ключевые слова делистинга
3. Или в тегах объявления есть `SYMBOL_DELISTING`

#### 4. Обработка результатов

**Если делистинг найден:**
- Выводится предупреждение в лог: `⚠️ Найден делистинг {coin}: {title}... | URL: {url}`
- Показывается URL объявления для проверки деталей
- Бот продолжает работу, но пользователь предупрежден о риске

**Если делистинг не найден:**
- Выводится подтверждение: `✓ Новостей о делистинге {coin} за последние {days_back} дней не найдено`
- Бот продолжает нормальную работу

### Технические детали

**Обработка дат:**
- Все даты обрабатываются в UTC для корректного сравнения
- Используется `datetime.now(timezone.utc)` для текущего времени
- Даты публикации парсятся с указанием timezone: `datetime.fromtimestamp(ms/1000, tz=timezone.utc)`
- Буфер 6 часов предотвращает потерю событий на границе периода (например, если делистинг был ровно 60 дней назад)

**Дедупликация:**
- Объявления дедуплицируются по URL (убираются query-параметры типа `utm_*`)
- Сохраняется порядок по дате публикации (новые → старые)

**Оптимизация:**
- Для Bybit используется ранняя остановка пагинации, если найдены объявления старше периода поиска
- Проверка выполняется только на биржах из запроса, что ускоряет работу

### Пример работы

**Запрос:** `"OBOL Long (bybit), Short (gate)"`

**Процесс:**
1. Получение данных о ценах и фандингах с Bybit и Gate.io
2. Автоматическая проверка делистинга OBOL на Bybit и Gate.io за последние 60 дней
3. Если найден делистинг:
   ```
   ⚠️ Найден делистинг OBOL: Delisting of OBOLUSDT Perpetual Contract... | URL: https://announcements.bybit.com/...
   ```
4. Если делистинг не найден:
   ```
   ✓ Новостей о делистинге OBOL за последние 60 дней не найдено
   ```

### Проверка доступности монеты

**Важно:** Если тикер не найден на бирже (API возвращает пустой результат), монета автоматически помечается как недоступная/делистированная:

- Выводится предупреждение: `⚠️ {coin} недоступна/делистирована на {exchange}`
- Выводится сообщение: `Арбитраж невозможен: тикер не найден на бирже Long/Short`
- Дальнейшая обработка арбитража прекращается
- Проверка делистинга не выполняется (так как монета уже недоступна)

## Проверка ликвидности

### Назначение
Бот автоматически проверяет ликвидность на биржах перед открытием позиций. Это критически важно для оценки возможности выполнения сделок без значительного проскальзывания (slippage) и потери прибыли.

### Когда выполняется проверка
Проверка ликвидности выполняется автоматически после расчета спредов и перед проверкой делистинга. Проверяется ликвидность на обеих биржах (Long и Short) для размера сделки 150 USDT.

### Поддерживаемые биржи
- **Bybit** - через официальный API orderbook (`/v5/market/orderbook`)
- **Gate.io** - через официальный API orderbook (`/api/v4/futures/usdt/order_book`)
- **MEXC** - через официальный API orderbook (`/api/v1/contract/depth/{symbol}`)
- **XT.com** - через официальный API orderbook (`/future/market/v1/public/cg/orderbook`)
- **LBank** - через официальный API orderbook (`/cfd/openApi/v1/pub/depth`)
- **Binance** - через официальный API orderbook (`/fapi/v1/depth`)

### Размер сделки
Проверка выполняется для размера **150 USDT**, что соответствует типичной инвестиции на каждый ордер (Long и Short).

### Проверяемые параметры

#### 1. Top-of-book спред (Spread)
**Что проверяется:** Разница между лучшей ценой покупки (ask1) и лучшей ценой продажи (bid1) на первом уровне стакана.

**Формула:**
```
spread_bps = (ask1 - bid1) / mid * 10_000
```
где `mid = (bid1 + ask1) / 2.0`

**Порог:** ≤ 30 bps (0.30%)
- Если спред больше 30 bps, ликвидность считается недостаточной
- Большой спред означает высокую стоимость входа/выхода

#### 2. Глубина до размера сделки (Price Impact / Slippage)
**Что проверяется:** Эффективный проскальзывание при выполнении сделки заданного размера (VWAP - Volume Weighted Average Price).

**Метод расчета:**
1. Берется книга заявок (orderbook) с 50 уровнями
2. Рассчитывается VWAP для покупки (используя asks) и продажи (используя bids)
3. Вычисляется отклонение VWAP от top-of-book цены (ask1 для покупки, bid1 для продажи)

**Важно:** Impact считается относительно top-of-book, а не mid, чтобы разделить spread и impact:
- **Spread** = разница между ask1 и bid1 (стоимость входа из-за спреда)
- **Impact** = дополнительная потеря из-за глубины стакана (проскальзывание)

**Формула для buy impact:**
```
buy_impact_bps = |buy_vwap - ask1| / mid * 10_000
```
где `ask1` - лучшая цена продажи на первом уровне

**Формула для sell impact:**
```
sell_impact_bps = |bid1 - sell_vwap| / mid * 10_000
```
где `bid1` - лучшая цена покупки на первом уровне

**Порог:** ≤ 50 bps (0.50%) на сторону
- Рекомендуется ≤ 30 bps для лучшей ликвидности
- 50 bps - компромиссный вариант для реальных рынков
- Если проскальзывание больше порога, ликвидность недостаточна для размера сделки

#### 3. Достаточность объема (Depth)
**Что проверяется:** Хватает ли объема в стакане для выполнения сделки заданного размера.

**Метод:**
- Проверяется, можно ли купить/продать нужный номинал (150 USDT) в пределах 50 уровней стакана
- Если объема не хватает, VWAP не может быть рассчитан (возвращается `None`)

**Порог:** Должно хватать объема для полного номинала сделки

### Пороговые значения

**Рекомендуемые пороги для размера 150 USDT:**
- **max_spread_bps**: 30 (0.30%)
- **max_impact_bps**: 50 (0.50%) - компромиссный вариант
  - Лучше: 30 bps (0.30%) для более строгой проверки
- **orderbook_limit**: 50 уровней
  - Если часто "не хватает глубины", можно увеличить до 200 уровней

### Как работает проверка

#### 1. Получение orderbook
- Запрашивается книга заявок через API: `GET /v5/market/orderbook?category=linear&symbol=GPSUSDT&limit=50`
- Получаются списки bids (заявки на покупку) и asks (заявки на продажу)

#### 2. Режимы проверки
Проверка ликвидности может выполняться в трех режимах:

- **`entry_long`** - проверка для входа в Long позицию
  - Важна только глубина на покупку (`buy_vwap`)
  - Проверяется только `buy_impact_bps`
  - Используется для Long биржи
  
- **`entry_short`** - проверка для входа в Short позицию
  - Важна только глубина на продажу (`sell_vwap`)
  - Проверяется только `sell_impact_bps`
  - Используется для Short биржи
  
- **`roundtrip`** - проверка для полного цикла (вход + выход)
  - Нужны оба: `buy_vwap` и `sell_vwap`
  - Проверяются оба impact
  - Используется по умолчанию

**Логика:** В режиме `entry_long` не нужно заваливать проверку из-за большого `sell_impact`, так как входим только в Long. Аналогично для `entry_short`.

#### 3. Расчет метрик

**Спред:**
```
spread_bps = (ask1 - bid1) / mid * 10_000
```
где `mid = (bid1 + ask1) / 2.0`

**Расчет VWAP (Volume Weighted Average Price):**

Алгоритм расчета VWAP для заданного номинала:
1. Итерация по уровням стакана (asks для покупки, bids для продажи)
2. Для каждого уровня:
   - Вычисляется номинал уровня: `level_notional = price * size`
   - Берется нужное количество: `take = min(level_notional, remaining)`
   - Конвертируется в базовую монету: `take_sz = take / price`
   - Накопление: `filled_usdt += take`, `filled_base += take_sz`
   - Остаток: `remaining -= take`
3. Если `remaining <= 1e-9` - глубина достаточна
4. Если `remaining > 1e-6` - глубина недостаточна, возвращается `(None, filled_usdt)`
5. Расчет VWAP: `vwap = filled_usdt / filled_base`

**Buy VWAP:** Рассчитывается для покупки заданного номинала по asks (сверху вниз)
**Sell VWAP:** Рассчитывается для продажи заданного номинала по bids (сверху вниз)

**Buy Impact:**
```
buy_impact_bps = |buy_vwap - ask1| / mid * 10_000
```
Отклонение от лучшей цены продажи (ask1)

**Sell Impact:**
```
sell_impact_bps = |bid1 - sell_vwap| / mid * 10_000
```
Отклонение от лучшей цены покупки (bid1)

#### 4. Проверка условий
Проверка считается успешной (`ok = True`), если:
- Спред ≤ 30 bps
- Глубины хватает для нужной стороны:
  - `entry_long`: `buy_vwap is not None`
  - `entry_short`: `sell_vwap is not None`
  - `roundtrip`: оба `buy_vwap` и `sell_vwap` не None
- Impact для нужной стороны ≤ 50 bps:
  - `entry_long`: только `buy_impact_bps ≤ 50 bps`
  - `entry_short`: только `sell_impact_bps ≤ 50 bps`
  - `roundtrip`: оба impact ≤ 50 bps

Если хотя бы одно условие не выполнено, проверка считается неуспешной (`ok = False`).

### Вывод результатов

**Успешная проверка:**
```
✓ Ликвидность bybit Long (GPS): 150 USDT | spread=15.2bps, buy_impact=25.1bps
```

**Неуспешная проверка:**
```
✗ Ликвидность bybit Long (GPS): 150 USDT | spread=45.3bps, buy_impact=65.2bps
  Причины: spread 45.3 bps > 30.0, buy impact 65.2 bps > 50.0
```

### Почему это важно

**24h volume не гарантирует ликвидность:**
- Большой дневной объем не означает, что прямо сейчас на top-of-book есть достаточная глубина
- VWAP/impact по orderbook - самый прямой тест "хватит ли ликвидности для входа/выхода без убийства PnL"

**Преимущества проверки:**
- Показывает реальную стоимость входа/выхода (проскальзывание)
- Предотвращает открытие позиций на рынках с низкой ликвидностью
- Помогает оценить возможность выполнения сделки размером 150 USDT

### Технические детали

**API эндпоинты для orderbook:**

**Bybit:**
- `GET /v5/market/orderbook`
- Параметры: `category=linear`, `symbol=COINUSDT`, `limit=50`
- Возвращает: `{"retCode": 0, "result": {"b": [[price, size], ...], "a": [[price, size], ...]}}`

**Gate.io:**
- `GET /api/v4/futures/usdt/order_book`
- Параметры: `contract=COIN_USDT`, `limit=50`
- Возвращает: `{"bids": [[price, size], ...], "asks": [[price, size], ...]}`

**MEXC:**
- `GET /api/v1/contract/depth/{symbol}`
- Параметры: `{symbol}` в path (например, `/api/v1/contract/depth/DN_USDT`), `limit=50` в query (от 1 до 200)
- Возвращает: `{"code": 0, "data": {"bids": [[price, size], ...], "asks": [[price, size], ...]}}`
- **ВАЖНО:** Символ должен быть в path, а не в query параметрах

**XT.com:**
- `GET /future/market/v1/public/cg/orderbook`
- Параметры: `symbol=coin_usdt`, `level=50` (level ограничен от 1 до 200)
- Возвращает: `{"bids": [[price, size], ...], "asks": [[price, size], ...]}`

**LBank:**
- `GET /cfd/openApi/v1/pub/depth`
- Параметры: `productGroup=SwapU`, `symbol=COINUSDT`, `limit=50`
- Возвращает: `{"data": {"bids": [[price, size], ...], "asks": [[price, size], ...]}}`

**Binance:**
- `GET /fapi/v1/depth`
- Параметры: `symbol=COINUSDT`, `limit=50` (limit от 5 до 5000)
- Возвращает: `{"bids": [[price, size], ...], "asks": [[price, size], ...]}`

**Расчет VWAP (детально):**

Метод `_vwap_for_notional()` выполняет следующие шаги:

1. **Инициализация:**
   - `remaining = target_usdt` (целевой номинал в USDT)
   - `filled_usdt = 0.0` (накопленный номинал)
   - `filled_base = 0.0` (накопленное количество базовой монеты)

2. **Итерация по уровням стакана:**
   - Для каждого уровня `[price, size]`:
     - `level_notional = price * size` (номинал уровня в USDT)
     - `take = min(level_notional, remaining)` (сколько берем с этого уровня)
     - `take_sz = take / price` (количество базовой монеты)
     - `filled_usdt += take`
     - `filled_base += take_sz`
     - `remaining -= take`
     - Если `remaining <= 1e-9` → глубина достаточна, выходим

3. **Проверка результата:**
   - Если `filled_base <= 0` → возвращается `(None, 0.0)`
   - Если `remaining > 1e-6` → глубина недостаточна, возвращается `(None, filled_usdt)`
   - Иначе: `vwap = filled_usdt / filled_base`, возвращается `(vwap, target_usdt)`

**Обработка недостаточной глубины:**
- Если объема не хватает, `vwap = None`
- В лог выводится информация о том, сколько USDT удалось "заполнить" (`filled_usdt`)
- Сообщение формируется в зависимости от режима:
  - `entry_long`: показывает только `buy_filled`
  - `entry_short`: показывает только `sell_filled`
  - `roundtrip`: показывает оба `buy_filled` и `sell_filled`

**Валидация режима:**
- Если передан неверный `mode` (не `entry_long`, `entry_short`, `roundtrip`), выводится предупреждение и используется `roundtrip` по умолчанию

### Пример работы

**Запрос:** `"GPS Long (bybit), Short (xt)"`

**Процесс:**
1. Получение данных о ценах и фандингах с Bybit и XT
2. Расчет спредов
3. Автоматическая проверка ликвидности на Bybit (Long) для размера 150 USDT
4. Вывод результатов:
   ```
   ✓ Ликвидность bybit Long (GPS): 150 USDT | spread=12.5bps, buy_impact=22.1bps
   ```
5. Если ликвидность недостаточна:
   ```
   ✗ Ликвидность bybit Long (GPS): 150 USDT | spread=45.2bps, buy_impact=68.5bps
     Причины: spread 45.2 bps > 30.0, buy impact 68.5 bps > 50.0
   ```

